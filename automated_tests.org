* Writing Automated Tests

* How to Write Tests

  The bodies of test functions typically perform these three actions:
  1. set up any needed data or state
  2. run the code you want to test
  3. assert the results are what you expect

** The Anatomy of a Test Function

   A test in Rust is a function that is annotated with the test attribute. Attributes are metadata about pieces of Rust code.

   To change a function into a test function, add #[test] on the line before fn. When you run your test with the cargo test command, Rust builds a test runner binary that runs the functions annotated with the test attribute and reports on whether the test passes or fails.

   
#+name:
#+BEGIN_SRC rust
#[cfg(test)]
mod tests {
    // this makes it a test function
    #[test]
    fn it_works() {
	assert_eq!(2 + 2, 4);
    }
}
#+END_SRC

#+name:
#+BEGIN_SRC rust
#[cfg(test)]
mod tests {
    // this makes it a test function
    #[test]
    fn exploration() {
	assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
	panic!("Make this test fail!");
    }
}
#+END_SRC

** Checking Results with the assert! Macro

   With the assert! macro, if the value is true, the test passes. If the value is false, the assert! macro calls the panic! macro, which causes the test to fail.

#+name:
#+BEGIN_SRC rust 
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // returns a boolean, making it a perfect use case for the assert! macro
    fn can_hold(&self, other: &Rectangle) -> bool {
	self.width > other.width && self.height > other.height
    }
}

#[cfg(test)]
mod tests {
    // bring in objects from outside of the tests module
    use super::*;

    // passes!
    #[test]
    fn larger_can_hold_smaller() {
	let larger = Rectangle {
	    width: 8,
	    height: 7,
	};
	let smaller = Rectangle {
	    width: 5,
	    height: 1,
	};

	assert!(larger.can_hold(&smaller));
    }

    // passes since the correct result is false
    #[test]
    fn smaller_cannot_hold_larger() {
	let larger = Rectangle {
	    width: 8,
	    height: 7,
	};
	let smaller = Rectangle {
	    width: 5,
	    height: 1,
	};

	assert!(!smaller.can_hold(&larger));
    }
}
#+END_SRC

** Testing Equality with the assert_eq! and assert_ne! Macros

#+name:
#+BEGIN_SRC rust 
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
	assert_eq!(4, add_two(2));
    }
}
#+END_SRC

** Adding Custom Failure Messages

   You can also add a custom message to be printed with the failure message as optional arguments to the assert!, assert_eq!, and assert_ne! macros.

#+name:
#+BEGIN_SRC rust 
pub fn greeting(name: &str) -> String {
    format!("Helloooo!")
}

#[cfg(test)]
mod tests {
    use super::*;
    // just check whether the output contains 'something'
    #[test]
    fn greeting_contains_name() {
	let result = greeting("Carol");
	assert!(result.contains("Carol"),
		"Greeting did not contain name, value was `{}`",
		result);
    }
}
#+END_SRC

** Checking for Panics with should_panic

   We also want our code to handle error conditions as we expect

   should panic tests are imprecise because our code could panic for reasons aside from the one we were expecting.
   To make should panic tests more precise, we can add an optional expected parameter to the should_panic attribute.
#+name:
#+BEGIN_SRC rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
	if value < 1 {
	    panic!("Guess value must be greater than 1, got {}.", value);
	} else if value > 100 {
	    panic!("Guess value must be less than or equal to 100, got {}", value);
	}

	Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "Guess value must be less than or equal to 100")]
    fn greater_than_100() {
	Guess::new(200);
    }
}
#+END_SRC

** Using Result<T, E> in Tests

   We can also write tests that use Result<T, E>
   
#+name:
#+BEGIN_SRC rust :tangle adder/src/lib.rs 
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
	if 2 + 2 == 4 {
	    Ok(())
	} else {
	    Err(String::from("two plus two does not equal four"))
	}
    }
}
#+END_SRC 

