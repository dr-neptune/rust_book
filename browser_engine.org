* Let's build a browser engine!

  All glory to [[https://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html][Matt Brubeck's Blog]]

  This may take longer than a day, so here is an outline of the series:

  1. Getting Started
  2. HTML
  3. CSS
  4. Style
  5. Boxes
  6. Block Layout
  7. Painting 101

  A browser engine is the portion of a web browser that fetches a web page from the internet and translates its contents into forms you can read, watch, hear, etc.

  Blink, Gecko, Webkit, and Trident are browser engines, whereas the UI (tabs, toolbar, menu, etc) is called the chrome.

  A browser engine includes many subcomponents: a HTTP client, a HTML parser, a CSS parser, a JavaScript engine (itself composed to parsers, interpreters, and compilers), and much more.
  These components involved in parsing web formats like HTML and CSS and translating them into what we see on screen are sometimes called the layout engine or rendering engine.

* The DOM

  The DOM is a tree of nodes. A node has zero or more children.

#+name: dom-node
#+BEGIN_SRC rust :tangle browser_engine/src/dom.rs
use std::collections::{HashMap, HashSet};
pub type AttrMap = HashMap<String, String>;

#[derive(Debug)]
pub struct Node {
    // data common to all nodes
    pub children: Vec<Node>,
    // data specific to each node type
    pub node_type: NodeType,
}

// there are several node types. We will just use Element or Text here
// enums allow you to define a type by enumerating its possible variants
#[derive(Debug)]
pub enum NodeType {
    Text(String),
    Element(ElementData),
}

// an element includes a tag name and any number of attributes, which can be stored as a map from names to values.
// we don't have namespaces, so we just store tag and attribute names as simple strings
#[derive(Debug)]
pub struct ElementData {
    pub tag_name: String,
    pub attributes: AttrMap,
}

// constructor functions to make it easy to create new nodes
pub fn text(data: String) -> Node {
    Node {
	children: Vec::new(),
	node_type: NodeType::Text(data)
    }
}

pub fn elem(name: String, attrs: AttrMap, children: Vec<Node>) -> Node {
    Node {
	children: children,
	node_type: NodeType::Element(ElementData {
	    tag_name: name,
	    attributes: attrs,
	})
    }
}

impl ElementData {
    pub fn id(&self) -> Option<&String> {
	self.attributes.get("id")
    }

    pub fn classes(&self) -> HashSet<&str> {
	match self.attributes.get("class") {
	    Some(classList) => classList.split(' ').collect(),
	    None => HashSet::new()
	}
    }
}
#+END_SRC

* HTML

  This part is about parsing HTML source code to produce a tree of DOM nodes.

  HTML has its own unique parsing algorithm. Unlike other language parsers, the HTML parsing algorithm does not reject invalid input. Instead, it includes specific error handling instructions, so web browsers can agree on how to display every web page, even ones that don't conform to the syntax rules.

** A Simple HTML Dialect

   The parser can handle simple pages like this:
   
#+name:
#+BEGIN_SRC html
<html>
  <body>
    <h1>Title</h1>
    <div id="main" class="test">
      <p>Hello <em>World</em>!</p>
    </div>
  </body>
</html>
#+END_SRC

It allows:
- balanced tags
- attributes with quoted values, i.e. id="main"
- text nodes, i.e. <em>world</em>

everything else is not supported.

#+name: html-parser
#+BEGIN_SRC rust :tangle browser_engine/src/html.rs
use crate::dom::*;
use std::collections::HashMap;

// the parser stores its input string and a current position within the string
struct Parser {
    pos: usize,
    input: String,
}

// peek at the next character in the input
impl Parser {
    // read the current char without consuming it
    fn next_char(&self) -> char {
	self.input[self.pos..].chars().next().unwrap()
    }

    // do the next chars start with the given string?
    fn starts_with(&self, s: &str) -> bool {
	self.input[self.pos..].starts_with(s)
    }

    // return true is all input is consumed
    fn eof(&self) -> bool {
	self.pos >= self.input.len()
    }

    // return the current character, and advanced self.pos to the next character
    fn consume_char(&mut self) -> char {
	// consume_char correctly handles multibyte characters (since Strings are stored as UTF-8 byte arrays)
	let mut iter = self.input[self.pos..].char_indices();
	let (_, cur_char) = iter.next().unwrap();
	let (next_pos, _) = iter.next().unwrap_or((1, ' '));
	self.pos += next_pos;
	return cur_char;
    }

    // consume characters that meet a given condition, and return them as a string
    fn consume_while<F>(&mut self, test: F) -> String
    where F: Fn(char) -> bool {
	let mut result = String::new();
	while !self.eof() && test(self.next_char()) {
	    result.push(self.consume_char());
	}
	return result;
    }

    // we can use this to ignore a sequence of space characters, or to consume a string of alphanumeric characters.
    fn consume_whitespace(&mut self) {
	self.consume_while(char::is_whitespace);
    }
    
    // parse a tag or attribute name
    fn parse_tag_name(&mut self) -> String {
	self.consume_while(|c| match c {
	    'a'..='z' | 'A'..='Z' | '0'..='9' => true,
	    _ => false
	})
    }
    
    // parse a single node
    // check if element or a text node.
    fn parse_node(&mut self) -> Node {
	match self.next_char() {
	    '<' => self.parse_element(),
	    _   => self.parse_text()
	}
    }

    // parse a text node
    fn parse_text(&mut self) -> Node {
	text(self.consume_while(|c| c != '<'))
    }

    // parse a single element
    // contains opening and closing tags, and between them any number of child nodes
    fn parse_element(&mut self) -> Node {
	// Opening tag
	assert_eq!(self.consume_char(), '<');
	let tag_name = self.parse_tag_name();
	let attrs = self.parse_attributes();
	assert_eq!(self.consume_char(), '>');

	// contents of the element
	let children = self.parse_nodes();

	// closing tag
	assert_eq!(self.consume_char(), '<');
	assert_eq!(self.consume_char(), '/');
	assert_eq!(self.parse_tag_name(), tag_name);
	assert_eq!(self.consume_char(), '>');

	elem(tag_name, attrs, children)
    }

    // parsing attributes
    // until we reach the end of the opening tag, we repeatedly look for a name followed by = and then a string enclosed in quotes
    fn parse_attr(&mut self) -> (String, String) {
	let name = self.parse_tag_name();
	assert_eq!(self.consume_char(), '=');
	let value = self.parse_attr_value();
	(name, value)
    }

    // parse a quoted value
    fn parse_attr_value(&mut self) -> String {
	let open_quote = self.consume_char();
	assert!(open_quote == '"' || open_quote == '\'');
	let value = self.consume_while(|c| c != open_quote);
	assert_eq!(self.consume_char(), open_quote);
	value
    }
    
    // parse a list of name="value" pairs, separated by whitespace
    fn parse_attributes(&mut self) -> AttrMap {
	let mut attributes = HashMap::new();
	loop {
	    self.consume_whitespace();
	    if self.next_char() == '>' {
		break;
	    }
	    let (name, value) = self.parse_attr();
	    attributes.insert(name, value);
	}
	attributes
    }

    // to parse the child nodes, we recursively call parse_node in a loop until we reach the closing tag
    fn parse_nodes(&mut self) -> Vec<Node> {
	let mut nodes = Vec::new();
	loop {
	    self.consume_whitespace();
	    if self.eof() || self.starts_with("</") {
		break;
	    }
	    nodes.push(self.parse_node());
	}
	return nodes;
    }
}

// put it all together to parse an entire HTML document into a DOM tree
// creates a root node for the document if it doesn't include one explicitly.
pub fn parse(source: String) -> Node {
    let mut nodes = Parser {
	pos: 0,
	input: source
    }.parse_nodes();

    // if the document contains a root element, return it. otherwise create it
    if nodes.len() == 1 {
	nodes.swap_remove(0)
    } else {
	elem("html".to_string(), HashMap::new(), nodes)
    }
}
#+END_SRC

* CSS
  
Next we look at CSS. Here is an example of CSS source code:

#+name: css-example
#+BEGIN_SRC css
h1, h2, h3 { margin: auto; color: #cc0000; }
div.note { margin-bottom: 20px; padding: 10px; }
#answer { display: none; }
#+END_SRC

and now the CSS module:

#+name: css
#+BEGIN_SRC rust :tangle browser_engine/src/css.rs 
// a CSS stylesheet is a series of rules.
#[derive(Debug)]
pub struct Stylesheet {
    pub rules: Vec<Rule>,
}

// a rule includes one or more selectors separated by commas, followed by a series of declarations enclosed in braces
#[derive(Debug)]
pub struct Rule {
    pub selectors: Vec<Selector>,
    pub declarations: Vec<Declaration>,
}

// a simple selector can include a tag name, an ID prefixed by '#', any number of class names prefixed by '.', or some combination of the above.
#[derive(Debug)]
pub enum Selector {
    Simple(SimpleSelector),
}

#[derive(Debug)]
pub struct SimpleSelector {
    pub tag_name: Option<String>,
    pub id: Option<String>,
    pub class: Vec<String>,
}

// a declaration is just a name/value pair, separated by a colon and ending with a semi-colon
#[derive(Debug)]
pub struct Declaration {
    pub name: String,
    pub value: Value,
}

// support a handful of CSS value types
#[derive(Debug, Clone, PartialEq)]
pub enum Value {
    Keyword(String),
    Length(f32, Unit),
    ColorValue(Color),
}

#[derive(Debug, Clone, PartialEq)]
pub enum Unit {
    Px,
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Color {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}

impl Copy for Color {}

// specificity is one of the ways a rendering engine decides which style overrides the other in a conflict.
// if a stylesheet contains two rules that match an element, the rule with the matching selector of higher specificity
// can override values from the one with lower specificity
pub type Specificity = (usize, usize, usize);

impl Selector {
    pub fn specificity(&self) -> Specificity {
	let Selector::Simple(ref simple) = *self;
	let a = simple.id.iter().count();
	let b = simple.class.len();
	let c = simple.tag_name.iter().count();
	(a, b, c)
    }
}

// this was on the github file, but not in the tutorial
impl Value {
    // return the size of a length in px, or zero for non-lengths.
    pub fn to_px(&self) -> f32 {
	match *self {
	    Value::Length(f, Unit::Px) => f,
	    _ => 0.0
	}
    }
}
 
// parsing
// CSS has a regular grammar, making it easier to parse correctly than HTML
pub struct Parser {
    pub pos: usize,
    pub input: String,
}

impl Parser {
    // Parse a list of rule sets, separated by optional whitespace.
    fn parse_rules(&mut self) -> Vec<Rule> {
	let mut rules = Vec::new();
	loop {
	    self.consume_whitespace();
	    if self.eof() { break }
	    rules.push(self.parse_rule());
	}
	rules
    }

    // parse a ruleset: `<selectors> { <declarations> }`.
    fn parse_rule(&mut self) -> Rule {
	Rule {
	    selectors: self.parse_selectors(),
	    declarations: self.parse_declarations(),
	}
    }

    // parse a comma separated list of selectors
    fn parse_selectors(&mut self) -> Vec<Selector> {
	let mut selectors = Vec::new();
	loop {
	    selectors.push(Selector::Simple(self.parse_simple_selector()));
	    self.consume_whitespace();
	    match self.next_char() {
		',' => { self.consume_char(); self.consume_whitespace(); }
		'{' => break, // start of declarations
		c => panic!("Unexpected cahracter {} in selector list", c)
	    }
	}
	// return selectors with highest specificity first, for use in matching
	selectors.sort_by(|a,b| b.specificity().cmp(&a.specificity()));
	return selectors;
    }
    
    // parse one simple selector, e.g: `type#id.class1.class2.class3`
    fn parse_simple_selector(&mut self) -> SimpleSelector {
	let mut selector = SimpleSelector { tag_name: None, id: None, class: Vec::new() };
	while !self.eof() {
	    match self.next_char() {
		'#' => {
		    self.consume_char();
		    selector.id = Some(self.parse_identifier());
		}
		'.' => {
		    self.consume_char();
		    selector.class.push(self.parse_identifier());
		}
		'*' => {
		    // universal selector
		    self.consume_char();
		}
		c if valid_identifier_char(c) => {
		    selector.tag_name = Some(self.parse_identifier());
		}
		_ => break
	    }
	}
	selector
    }

    // parse a list of declarations enclosed in `{ ... }`
    fn parse_declarations(&mut self) -> Vec<Declaration> {
	assert_eq!(self.consume_char(), '{');
	let mut declarations = Vec::new();
	loop {
	    self.consume_whitespace();
	    if self.next_char() == '}' {
		self.consume_char();
		break;
	    }
	    declarations.push(self.parse_declaration());
	}
	declarations
    }

    // parse one `<property>: <value>;` declaration.
    fn parse_declaration(&mut self) -> Declaration {
	let property_name = self.parse_identifier();
	self.consume_whitespace();
	assert_eq!(self.consume_char(), ':');
	self.consume_whitespace();
	let value = self.parse_value();
	self.consume_whitespace();
	assert_eq!(self.consume_char(), ';');

	Declaration {
	    name: property_name,
	    value: value,
	}
    }

    // methods for parsing values
    fn parse_value(&mut self) -> Value {
	match self.next_char() {
	    '0'..='9' => self.parse_length(),
	    '#' => self.parse_color(),
	    _ => Value::Keyword(self.parse_identifier())
	}
    }

    fn parse_length(&mut self) -> Value {
	Value::Length(self.parse_float(), self.parse_unit())
    }

    fn parse_float(&mut self) -> f32 {
	let s = self.consume_while(|c| match c {
	    '0'..='9' | '.' => true,
	    _ => false
	});
	s.parse().unwrap()
    }

    fn parse_unit(&mut self) -> Unit {
	match &*self.parse_identifier().to_ascii_lowercase() {
	    "px" => Unit::Px,
	    _ => panic!("unrecognized unit")
	}
    }

    fn parse_color(&mut self) -> Value {
	assert_eq!(self.consume_char(), '#');
	Value::ColorValue(Color {
	    r: self.parse_hex_pair(),
	    g: self.parse_hex_pair(),
	    b: self.parse_hex_pair(),
	    a: 255
	})
    }

    // parse 2 hexadecimal digits
    fn parse_hex_pair(&mut self) -> u8 {
	let s = &self.input[self.pos .. self.pos + 2];
	self.pos += 2;
	u8::from_str_radix(s, 16).unwrap()
    }

    // parse a property name or keyword
    fn parse_identifier(&mut self) -> String {
	self.consume_while(valid_identifier_char)
    }

    // consume and discard zero or more whitespace characters
    fn consume_whitespace(&mut self) {
	self.consume_while(char::is_whitespace);
    }

    // consume characters until `test` returns false
    fn consume_while<F>(&mut self, test: F) -> String
    where F: Fn(char) -> bool {
	let mut result = String::new();
	while !self.eof() && test(self.next_char()) {
	    result.push(self.consume_char());
	}
	result
    }

    // return the current character and advance self.pos to the next character
    fn consume_char(&mut self) -> char {
	let mut iter = self.input[self.pos..].char_indices();
	let (_, cur_char) = iter.next().unwrap();
	let (next_pos, _) = iter.next().unwrap_or((1, ' '));
	self.pos += next_pos;
	cur_char
    }

    // read the current character without consuming it
    fn next_char(&self) -> char {
	self.input[self.pos..].chars().next().unwrap()
    }

    // return true if all input is consumed
    fn eof(&self) -> bool {
	self.pos >= self.input.len()
    }
}

fn valid_identifier_char(c: char) -> bool {
    match c {
	'a'..='z' | 'A'..='Z' | '0'..='9' | '-' | '_' => true,
	_ => false,
    }
}
#+END_SRC

* Style
  
In this next section, style, we cover what the CSS standard calls assigning property values. This module takes DOM nodes and CSS rules as input, and matches them up to determine the value of each CSS property for any given node.

A browser engine often takes on tree as input, and produces a different but related tree as output. Later stages in the engines produce more trees, including layer trees and widget trees.

The pipeline for the toy browser engine will look something like this after we complete a few more stages:

https://limpet.net/mbrubeck/images/2014/pipeline.svg

In this implementation, each node in the DOM tree has exactly one node in the style tree. 

#+name: style
#+BEGIN_SRC rust :tangle browser_engine/src/style.rs
use crate::dom::{Node, NodeType, ElementData};
use crate::css::{Stylesheet, Rule, Selector, SimpleSelector, Value, Specificity};
use std::collections::HashMap;

// Map from CSS property names to values
type PropertyMap = HashMap<String, Value>;

// A node with associated style data
pub struct StyledNode<'a> { // the 'a is a lifetime, part of how Rust guarantees that pointers are memory safe without requiring garbage collection 
    pub node: &'a Node, // pointer to a DOM node
    pub specified_values: PropertyMap,
    pub children: Vec<StyledNode<'a>>,
}

#[derive(PartialEq)]
pub enum Display {
    Inline,
    Block,
    None,
}

impl<'a> StyledNode<'a> {
    // return the specified value of a property if it exists, otherwise `None`.
    pub fn value(&self, name: &str) -> Option<Value> {
	self.specified_values.get(name).cloned()
    }

    // Return the specified value of property `name` or property `fallback_name` if that doesn't exist, or value `default` if neither does
    pub fn lookup(&self, name: &str, fallback_name: &str, default: &Value) -> Value {
	self.value(name).unwrap_or_else(|| self.value(fallback_name)
					.unwrap_or_else(|| default.clone()))
    }

    // The value of the `display` property (defaults to inline)
    pub fn display(&self) -> Display {
	match self.value("display") {
	    Some(Value::Keyword(s)) => match &*s {
		"block" => Display::Block,
		"none" => Display::None,
		_ => Display::Inline
	    },
	    _ => Display::Inline
	}
    }
}

// the first step in building the style tree is selector matching
// we can tell whether a simple selector matches an element just by looking at the element itself
fn matches(elem: &ElementData, selector: &Selector) -> bool {
    match *selector {
	Selector::Simple(ref simple_selector) => matches_simple_selector(elem, simple_selector)
    }
}

// test whether a simple selector matches an element
// look at each selector component, and return false if the element doesn't have a matching class, ID, or tag name
fn matches_simple_selector(elem: &ElementData, selector: &SimpleSelector) -> bool {
    // Check type selector
    if selector.tag_name.iter().any(|name| elem.tag_name != *name) {
	return false
    }

    // Check ID selector
    if selector.id.iter().any(|id| elem.id() != Some(id)) {
	return false
    }

    // Check class selectors
    let elem_classes = elem.classes();
    if selector.class.iter().any(|class| !elem_classes.contains(&**class)) {
	return false
    }

    // didn't find any non matching selector components
    true
}


// we need to traverse the DOM tree. For each element in the tree, we search the stylesheet for matching rules
// when comparing 2 rules that match the same element, we need to use the highest specificity selector from each match
// A single CSS rule and the specificity of its most specific matching selector
type MatchedRule<'a> = (Specificity, &'a Rule);

// if `rule` matches `elem`, return a `MatchedRule`. Otherwise, return `None`
fn match_rule<'a>(elem: &ElementData, rule: &'a Rule) -> Option<MatchedRule<'a>> {
    // Find the first (highest specificity) matching selector
    rule.selectors.iter()
	.find(|selector| matches(elem, *selector))
	.map(|selector| (selector.specificity(), rule))
}

// to find all the rules that match an element, we call filter_map, which does a linear scan through the style sheet, checking every rule and throwing out ones which don't match.
// find all CSS rules that match the given element
fn matching_rules<'a>(elem: &ElementData, stylesheet: &'a Stylesheet) -> Vec<MatchedRule<'a>> {
    stylesheet.rules.iter().filter_map(|rule| match_rule(elem, rule)).collect()
}

// once we have matching rules, we can find the specified values for the element.
// we insert each rules property values into a HashMap. We sort the matches by specificity, so the more specific rules are processed after the less specific ones, and can overwrite their values in the HashMap
// Apply styles to a single element, returning the specified values
fn specified_values(elem: &ElementData, stylesheet: &Stylesheet) -> PropertyMap {
    let mut values = HashMap::new();
    let mut rules = matching_rules(elem, stylesheet);

    // Go through the rules from lowest to highest specificity
    rules.sort_by(|&(a, _), &(b, _)| a.cmp(&b));
    for (_, rule) in rules {
	for declaration in &rule.declarations {
	    values.insert(declaration.name.clone(), declaration.value.clone());
	}
    }
    values
}

// now we have everything we need to walk through the DOM tree and build the style tree.
// Apply a stylesheet to an entire DOM tree, returning a StyledNode tree
pub fn style_tree<'a>(root: &'a Node, stylesheet: &'a Stylesheet) -> StyledNode<'a> {
    StyledNode {
	node: root,
	specified_values: match root.node_type {
	    NodeType::Element(ref elem) => specified_values(elem, stylesheet),
	    NodeType::Text(_) => HashMap::new()
	},
	children: root.children.iter().map(|child| style_tree(child, stylesheet)).collect(),
    }
}
#+END_SRC

* Boxes

  This section begins the layout module, which takes the style tree and translates it into a bunch of rectangles in a two dimensional space.

  The layout module's input is the style tree, and its output is another tree -- the layout tree.

  Layout is all about boxes. A box is a rectangular section of a web page. It has a width, a height, and a position on the page. This rectangle is called the content area,
  because its where the box's content is drawn. A box may also have padding, borders, and margins surrounding its content area.

#+name: layout
#+BEGIN_SRC rust :tangle browser_engine/src/layout.rs
use crate::style::StyledNode;
use crate::css::Value::{Keyword, Length};
use crate::css::Unit::Px;
use std::default::Default;

pub use self::BoxType::{AnonymousBlock, InlineNode, BlockNode};

// CSS box model. All sizes are in px.
#[derive(Clone, Copy, Default, Debug)]
pub struct Dimensions {
    // position of the content area relative to the document origin:
    pub content: Rect,
    // Surrounding edges:
    pub padding: EdgeSizes,
    pub border: EdgeSizes,
    pub margin: EdgeSizes,
}

#[derive(Clone, Copy, Default, Debug)]
pub struct Rect {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
}

#[derive(Clone, Copy, Default, Debug)]
pub struct EdgeSizes {
    pub left: f32,
    pub right: f32,
    pub top: f32,
    pub bottom: f32,
}

// The Layout Tree is a collection of boxes. A box has dimensions, and it may contain child boxes.
pub struct LayoutBox<'a> {
    pub dimensions: Dimensions,
    pub box_type: BoxType<'a>,
    pub children: Vec<LayoutBox<'a>>,
}

// a block can be a block node, an inline node, or an anonymous block box
pub enum BoxType<'a> {
    BlockNode(&'a StyledNode<'a>),
    InlineNode(&'a StyledNode<'a>),
    AnonymousBlock,
}

// now we can walk through the style tree, build a LayoutBox for each node, and then insert boxes for the node's children.
fn build_layout_tree<'a>(style_node: &'a StyledNode<'a>) -> LayoutBox<'a> {
    // Create the root box
    let mut root = LayoutBox::new(match style_node.display() {
	Block => BlockNode(style_node),
	Inline => InlineNode(style_node),
	DisplayNone => panic!("Root node has display: none.")
    });

    // Create the descendant boxes
    for child in &style_node.children {
	match child.display() {
	    Block => root.children.push(build_layout_tree(child)),
	    Inline => root.get_inline_container().children.push(build_layout_tree(child)),
	    DisplayNone => {} // Skip nodes with `display: none;`
	}
    }
    root
}

impl<'a> LayoutBox<'a> {
    // Constructor function
    fn new(box_type: BoxType) -> LayoutBox {
	LayoutBox {
	    box_type: box_type,
	    dimensions: Default::default(), // initially set all fields to 0.0
	    children: Vec::new(),
	}
    }

    fn get_style_node(&self) -> &'a StyledNode<'a> {
	match self.box_type {
	    BlockNode(node) | InlineNode(node) => node,
	    AnonymousBlock => panic!("Anonymous block box has no style node")
	}
    }

    // if a block node contains an inline child, create an anonymous block box to contain it.
    // if there are several inline children in a row, put them all in the same anonymous container
    // fn get_inline_container(&mut self) -> &mut LayoutBox {
    // 	match self.box_type {
    // 	    InlineNode(_) | AnonymousBlock => self,
    // 	    BlockNode(_) => {
    // 		// if we've just generated an anonymous block box, keep using it. otherwise create a new one
    // 		match self.children.last() {
    // 		    Some(&LayoutBox { box_type: AnonymousBlock, ..}) => {}
    // 		    _ => self.children.push(LayoutBox::new(AnonymousBlock))
    // 		}
    // 		self.children.last_mut().unwrap()
    // 	    }
    // 	}
    // }

    // this takes a LayoutBox and calculates its dimensions
    fn layout(&mut self, containing_block: Dimensions) {
	match self.box_type {
	    BlockNode(_) => self.layout_block(containing_block),
	    InlineNode(_) | AnonymousBlock => {} // TODO
	}
    }

    // A blocks layout depends on the dimensions of its containing block. For block boxes in normal flow, this is just the boxes parent
    // For the root element, its the size of the browser window (or viewport)
    // A blocks width depends on its parent, and a blocks height depends on its children.
    // therefore our code needs to traverse the tree top-down while calculating widths, so it can lay out the children after the parent's width is known
    // and traverse bottom up to calculate heights, so that a parent's height is calculated after its childrens
    fn layout_block(&mut self, containing_block: Dimensions) {
	// child width can depend on parent width, so we must calc this box's width before laying out its children
	self.calculate_block_width(containing_block);

	// determine where the box is located within its container
	self.calculate_block_position(containing_block);

	// recursively lay out the children of this box
	self.layout_block_children();

	// parent height can depend on child height, so calculate_height must be called *after* the children are laid out
	self.calculate_block_height();
    }

    // calculate block width
    fn calculate_block_width(&mut self, containing_block: Dimensions) {
	let style = self.get_style_node();

	// width has initial value auto
	let auto = Keyword("auto".to_string());
	let mut width = style.value("width").unwrap_or(auto.clone());

	// margin, border, and padding have initial value 0
	let zero = Length(0.0, Px);

	// lookup tries a series of values in sequence. If the first property isn't set, it tries the second one, if not then etc or default.
	let mut margin_left = style.lookup("margin-left", "margin", &zero);
	let mut margin_right = style.lookup("margin-right", "margin", &zero);

	let mut border_left = style.lookup("border-left-width", "border-width", &zero);
	let mut border_right = style.lookup("border-right-width", "border-width", &zero);

	let mut padding_left = style.lookup("padding-left", "padding", &zero);
	let mut padding_right = style.lookup("padding-right", "padding", &zero);

	// since a child can't change its parent's width, it needs to make sure its own width fits the parents.
	// The CSS spec expresses this as a set of constaints and an algorithm for solving them
	// the following code implements that algorithm
	// first we add the margin, padding, border, and content widths
	let total = sum([&margin_left, &margin_right,
		     &border_left, &border_right,
		     &padding_left, &padding_right, &width]
	    .iter().map(|v| v.to_px()));

	// this is the min horizontal space needed for the box. If this dne the width, we must adjust to make it equal
	if width != auto && total > containing_block.content.width {
	    if margin_left == auto {
		margin_left = Length(0.0, Px);
	    }
	    if margin_right == auto {
		margin_right = Length(0.0, Px);
	    }
	}

	// if a box is too big for its container, it overflows the container. If too small, it underflows, leaving extra space
	let underflow = containing_block.content.width - total;

	// eliminate any over/underflow by adjusting the expandable dimensions. If there are no 'auto' dimensions, we adjust the right margin
	match (width == auto, margin_left == auto, margin_right == auto) {
	    // if the values are overconstrained, calculate margin_right
	    (false, false, false) => {
		margin_right = Length(margin_right.to_px() + underflow, Px);
	    }
	    
	    // if exactly one size is auto, its used value follows from the equality
	    (false, false, true) => { margin_right = Length(underflow, Px); }
	    (false, true, false) => { margin_left = Length(underflow, Px); }

	    // if width is set to auto, any other auto values become 0
	    (true, _, _) => {
		if margin_left == auto { margin_left = Length(0.0, Px); }
		if margin_right == auto { margin_right = Length(0.0, Px); }

		if underflow >= 0.0 {
		    // expand width to fill the underflow
		    width = Length(underflow, Px);
		} else {
		    // Width can't be negative. Adjust the right margin instead
		    width = Length(0.0, Px);
		    margin_right = Length(margin_right.to_px() + underflow, Px);
		}
	    }

	    // if margin-left and margin-right are both auto, their used values are equal
	    (false, true, true) => {
		margin_left = Length(underflow / 2.0, Px);
		margin_right = Length(underflow / 2.0, Px);
	    }
	}
	
	// at this point, the constaints are met and any 'auto' values have been converted to lengths
	// the results are the used values for the horizontal box dimensions, which we will store in the layout tree
	let d = &mut self.dimensions;
	d.content.width = width.to_px();

	d.padding.left = padding_left.to_px();
	d.padding.right = padding_right.to_px();

	d.border.left = border_left.to_px();
	d.border.right = border_right.to_px();

	d.margin.left = margin_left.to_px();
	d.margin.right = margin_right.to_px();
    }

    // Positioning
    // this fn looks up the remaining margin/padding/border styles, and uses these along with the containing block dimensions to determine this block's position on the page.
    fn calculate_block_position(&mut self, containing_block: Dimensions) {
	let style = self.get_style_node();
	let d = &mut self.dimensions;

	// margin, border, and padding have initial value 0
	let zero = Length(0.0, Px);

	// if margin-top or margin-bottom is `auto`, the used value is zero
	d.margin.top = style.lookup("margin-top", "margin", &zero).to_px();
	d.margin.bottom = style.lookup("margin-bottom", "margin", &zero).to_px();

	d.border.top = style.lookup("border-top-width", "border-width", &zero).to_px();
	d.border.bottom = style.lookup("border-bottom-width", "border-width", &zero).to_px();

	d.padding.top = style.lookup("padding-top", "padding", &zero).to_px();
	d.padding.bottom = style.lookup("padding-bottom", "padding", &zero).to_px();

	d.content.x = containing_block.content.x + d.margin.left + d.border.left + d.padding.left;

	// Position the box below all the previous boxes in the container
	// this is what gives block layout its distinctive vertical stacking behavior
	d.content.y = containing_block.content.height + containing_block.content.y + d.margin.top + d.border.top + d.padding.top;
    }

    // Children
    // Here is the code that recursively lays out the box's contents. As it looks through the child boxes, it keeps track of the total content height.
    // this is used by the positioning code to find the vertical position of the next child
    fn layout_block_children(&mut self) {
	let d = &mut self.dimensions;
	for child in &mut self.children {
	    child.layout(*d);
	    // Track the height so each child is laid out below the previous content
	    d.content.height = d.content.height + child.dimensions.margin_box().height;
	}
    }

    // By default, the boxes height is equal to the height of its contents. If we set the height property explicitly, use that instead
    fn calculate_block_height(&mut self) {
	// If height is set to an explicit length, use that exact length. OW, just keep the value set by layout_block_children
	if let Some(Length(h, Px)) = self.get_style_node().value("height") {
	    self.dimensions.content.height = h;
	}
    }

    // where a new inline child should go
    fn get_inline_container(&mut self) -> &mut LayoutBox<'a> {
	match self.box_type {
	    InlineNode(_) | AnonymousBlock => self,
	    BlockNode(_) => {
		// If we've generated an anonymous block, keep using it. OW generate a new one
		match self.children.last() {
		    Some(&LayoutBox {box_type: AnonymousBlock,..}) => {}
		    _ => self.children.push(LayoutBox::new(AnonymousBlock))
		}
		self.children.last_mut().unwrap()
	    }
	}
    }
}

impl Rect {
    pub fn expanded_by(self, edge: EdgeSizes) -> Rect {
	Rect {
	    x: self.x - edge.left,
	    y: self.y - edge.top,
	    width: self.width + edge.left + edge.right,
	    height: self.height + edge.top + edge.bottom,
	}
    }
}

impl Dimensions {
    // The area covered by the content area plus its padding
    pub fn padding_box(self) -> Rect {
	self.content.expanded_by(self.padding)
    }

    // The area covered by the content area plus padding and borders
    pub fn border_box(self) -> Rect {
	self.padding_box().expanded_by(self.border)
    }

    // The area covered by the content area plus padding, borders, and margin
    pub fn margin_box(self) -> Rect {
	self.border_box().expanded_by(self.margin)
    }
}

fn sum<I>(iter: I) -> f32 where I: Iterator<Item=f32> {
    iter.fold(0., |a, b| a + b)
}
#+END_SRC

* Painting

  This code takes the tree of boxes from the layout module and turns them into an array of pixels. This process is also known as rasterization.
  Here we write a rasterizer that can only paint one thing: rectangles.

#+name: painting
#+BEGIN_SRC rust :tangle browser_engine/src/painting.rs
use crate::layout::{AnonymousBlock, BlockNode, InlineNode, LayoutBox, Rect};
use crate::css::{Value, Color};

// before painting, we walk through the layout tree and build a display list. This is a list of graphics operations like "draw a circle", or "draw a string of text".
// the display list is useful because you can search it for items that will be covered up by later operations and remove them to eliminate wasted painting
// you can also modify and reuse the display list in cases where you know only certain items have changed.
// you can also use the same display list to generate different types of output (i.e. pixels for displaying on a screen, or vector graphics for sending to a printer)
type DisplayList = Vec<DisplayCommand>;

// only one type of command, build a solid color rectangle
#[derive(Debug)]
pub enum DisplayCommand {
    SolidColor(Color, Rect),
}

// to build the display list, we walk through the layout tree and generate a series of commands for each box.
fn build_display_list(layout_root: &LayoutBox) -> DisplayList {
    let mut list = Vec::new();
    render_layout_box(&mut list, layout_root);
    list
}

fn render_layout_box(list: &mut DisplayList, layout_box: &LayoutBox) {
    render_background(list, layout_box);
    render_borders(list, layout_box);

    for child in &layout_box.children {
	render_layout_box(list, child);
    }
}

// The background is just a solid rectangle. If no color specified, then set to transparent and we don't need to generate a display command
fn render_background(list: &mut DisplayList, layout_box: &LayoutBox) {
    get_color(layout_box, "background").map(|color|
					    list.push(DisplayCommand::SolidColor(color, layout_box.dimensions.border_box())));
}

// return the specified color for CSS property `name`, or None if no color was specified. 
fn get_color(layout_box: &LayoutBox, name: &str) -> Option<Color> {
    match layout_box.box_type {
	BlockNode(style) | InlineNode(style) => match style.value(name) {
	    Some(Value::ColorValue(color)) => Some(color),
	    _ => None
	},
	AnonymousBlock => None
    }
}

// The borders are similar, but instead of a rectangle, we draw four -- one for each edge of the box
fn render_borders(list: &mut DisplayList, layout_box: &LayoutBox) {
    let color = match get_color(layout_box, "border-color") {
	Some(color) => color,
	_ => return // bail out if no border-color is specified
    };

    let d = &layout_box.dimensions;
    let border_box = d.border_box();

    // Left border
    list.push(DisplayCommand::SolidColor(color, Rect {
	x: border_box.x,
	y: border_box.y,
	width: d.border.left,
	height: border_box.height,
    }));

    // Right border
    list.push(DisplayCommand::SolidColor(color, Rect {
	x: border_box.x + border_box.width - d.border.right,
	y: border_box.y,
	width: d.border.right,
	height: border_box.height,
    }));

    // Top border
    list.push(DisplayCommand::SolidColor(color, Rect {
	x: border_box.x,
	y: border_box.y,
	width: border_box.width,
	height: d.border.top,
    }));

    // Bottom border
    list.push(DisplayCommand::SolidColor(color, Rect {
	x: border_box.x,
	y: border_box.y + border_box.height - d.border.bottom,
	width: border_box.width,
	height: d.border.bottom,
    }));
}

// now that we've built the display list, we need to turn it into pixels by executing each DisplayCommand. We'll store the pixels in a Canvas
pub struct Canvas {
    pub pixels: Vec<Color>,
    pub width: usize,
    pub height: usize,
}

impl Canvas {
    // Create a blank canvas
    fn new(width: usize, height: usize) -> Canvas {
	let white = Color { r: 255, g: 255, b: 255, a: 255 };
	Canvas {
	    pixels: vec![white; width * height],
	    width: width,
	    height: height,
	}
    }

    // to paint a rectangle on the canvas, we just loop through its rows and columns
    fn paint_item(&mut self, item: &DisplayCommand) {
	match item {
	    &DisplayCommand::SolidColor(color, rect) => {
		// Clip the rectangle to the canvas boundaries
		let x0 = rect.x.clamp(0.0, self.width as f32) as usize;
		let y0 = rect.y.clamp(0.0, self.width as f32) as usize;
		let x1 = (rect.x + rect.width).clamp(0.0, self.width as f32) as usize;
		let y1 = (rect.y + rect.height).clamp(0.0, self.width as f32) as usize;

		for y in y0 .. y1 {
		    for x in x0 .. x1 {
			self.pixels[x + y * self.width] = color;
		    }
		}
	    }
	}
    }
}

// now we can put everything together in a paint function, which builds a display list and then rasterizes it to a canvas
// paint a tree of LayoutBoxes to an array of pixels
fn paint(layout_root: &LayoutBox, bounds: Rect) -> Canvas {
    let display_list = build_display_list(layout_root);
    let mut canvas = Canvas::new(bounds.width as usize, bounds.height as usize);
    for item in display_list {
	canvas.paint_item(&item);
    }
    canvas
}

trait Clamp {
    fn clamp(self, lower: Self, upper: Self) -> Self;
}

impl Clamp for f32 {
    fn clamp(self, lower: f32, upper: f32) -> f32 {
	self.max(lower).min(upper)
    }
}
#+END_SRC

* Main

  Now we can parse this HTML file:

#+BEGIN_SRC html :tangle browser_engine/rainbow.html
<div class="a">
  <div class="b">
    <div class="c">
      <div class="d">
	<div class="e">
	  <div class="f">
	    <div class="g">
	    </div>
	  </div>
	</div>
      </div>
    </div>
  </div>
</div>
#+END_SRC
  
  and this CSS file:

#+BEGIN_SRC css :tangle browser_engine/rainbow.css
 * { display: block; padding: 12px; }
/* .a { background: #ff0000; } */
/* .b { background: #ffa500; } */
/* .c { background: #ffff00; } */
/* .d { background: #008000; } */
/* .e { background: #0000ff; } */
/* .f { background: #4b0082; } */
/*  .g { background: #800080; } */

 .a { background: #69D2E7; }
 .b { background: #A7DBD8; }
 .c { background: #E0E4CC; }
 .d { background: #F38630; }
 .e { background: #FA6900; }
 .f { background: #4b0082; }
 .g { background: #800080; }
 
#+END_SRC  

to create an image!

#+name: main-fn
#+BEGIN_SRC rust 
#![allow(unstable)]

mod dom;
mod html;
mod css;
mod style;
mod layout;
mod painting;

use getopts::{optopt, getopts};
use std::default::Default;
use std::io::fs::File;
use std::os::args;

extern crate getopts;
extern crate image;

fn main() {
    // parse command-line options
    let opts = [
	optopt("h", "html", "HTML document", "FILENAME"),
	optopt("c", "css", "CSS stylesheet", "FILENAME"),
	optopt("o", "output", "Output file", "FILENAME",)
    ];

    let matches = match getopts(args().tail(), &opts) {
	Ok(m) => m,
	Err(f) => panic!(f.to_string())
    };
    
    // read input files
    let read_source = |&: arg_filename: Option<String>, default_filename: &str| {
	let path = match arg_filename {
	    Some(ref filename) => filename.as_slice(),
	    None => default_filename,
	};
	File::open(&Path::new(path)).read_to_string().unwrap()
    };

    let html = read_source(matches.opt_str("h"), "rainbow.html");
    let css = read_source(matches.opt_str("c"), "rainbow.css");

    // since we don't have an actual window, hard-code the viewport size
    let initial_containing_block = layout::Dimensions {
	content: layout::Rect { x: 0.0, y: 0.0, width: 800.0, height: 600.0 },
	padding: Default::default(),
	border: Default::default(),
	margin: Default::default(),
    };

    // parsing and rendering
    let root_node = html::parse(html);
    let stylesheet = css::parse(css);
    let style_root = style::style_tree(&root_node, initial_containing_block);
    let layout_root = layout::layout_tree(&style_root, initial_containing_block);
    let canvas = painting::paint(&layout_root, initial_containing_block.content);

    // create the output file
    let filename = matches.opt_str("o").unwrap_or("output.png".to_string());
    let file = File::create(&Path::new(filename.as_slice())).unwrap();

    // save an image
    let (w, h) = (canvas.width as u32, canvas.height as u32);
    let buffer: Vec<image::Rgba<u8>> = unsafe { std::mem::transmute(canvas.pixels) };
    let img = image::ImageBuffer::from_fn(w, h, Box::new(|&: x: u32, y: u32| buffer[(y * w + x) as usize]));

    let result = image::ImageRgba8(img).save(file, image::PNG);

    match result {
	Ok(_) => println!("Saved output as {}", filename);
	Err(_) => println!("Error saving output as {}", filename)
    }
}
#+END_SRC

#+name: main
#+BEGIN_SRC rust :tangle browser_engine/src/main.rs
#![allow(unstable)]

extern crate getopts;
extern crate image;

use getopts::{optopt,getopts};
use std::default::Default;
use std::io::fs::File;
use std::os::args;

mod css;
mod dom;
mod html;
mod layout;
mod style;
mod painting;

fn main() {
    // Parse command-line options:
    let opts = [
        optopt("h", "html", "HTML document", "FILENAME"),
        optopt("c", "css", "CSS stylesheet", "FILENAME"),
        optopt("o", "output", "Output file", "FILENAME"),
    ];
    let matches = match getopts(args().tail(), &opts) {
        Ok(m) => m,
        Err(f) => panic!(f.to_string())
    };

    // Read input files:
    let read_source = |&: arg_filename: Option<String>, default_filename: &str| {
        let path = match arg_filename {
            Some(ref filename) => filename.as_slice(),
            None => default_filename,
        };
        File::open(&Path::new(path)).read_to_string().unwrap()
    };
    let html = read_source(matches.opt_str("h"), "examples/test.html");
    let css  = read_source(matches.opt_str("c"), "examples/test.css");

    // Since we don't have an actual window, hard-code the "viewport" size.
    let initial_containing_block = layout::Dimensions {
        content: layout::Rect { x: 0.0, y: 0.0, width: 800.0, height: 600.0 },
        padding: Default::default(),
        border: Default::default(),
        margin: Default::default(),
    };

    // Parsing and rendering:
    let root_node = html::parse(html);
    let stylesheet = css::parse(css);
    let style_root = style::style_tree(&root_node, &stylesheet);
    let layout_root = layout::layout_tree(&style_root, initial_containing_block);
    let canvas = painting::paint(&layout_root, initial_containing_block.content);

    // Create the output file:
    let filename = matches.opt_str("o").unwrap_or("output.png".to_string());
    let file = File::create(&Path::new(filename.as_slice())).unwrap();

    // Save an image:
    let (w, h) = (canvas.width as u32, canvas.height as u32);
    let buffer: Vec<image::Rgba<u8>> = unsafe { std::mem::transmute(canvas.pixels) };
    let img = image::ImageBuffer::from_fn(w, h, Box::new(|&: x: u32, y: u32| buffer[(y * w + x) as usize]));

    let result = image::ImageRgba8(img).save(file, image::PNG);
    match result {
        Ok(_) => println!("Saved output as {}", filename),
        Err(_) => println!("Error saving output as {}", filename)
    }
}
#+END_SRC
