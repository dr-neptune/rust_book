* Rust and WebAssembly

  This tutorial implements Conway's Game of Life in Rust and WebAssembly

* Setup

  We need the Rust toolchain (rustup, rustc, and cargo)

  We also need wasm-pack, cargo-generate, nodejs, and npm
  
* Hello, World!

  First we clone the project template

#+name:
#+BEGIN_SRC bash
cargo generate --git https://github.com/rustwasm/wasm-pack-template
#+END_SRC

here is our generated Cargo.toml:

#+name:
#+BEGIN_SRC toml
[package]
name = "wasm-game-of-life"
version = "0.1.0"
authors = ["dr-neptune <mrose4@worcester.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[features]
default = ["console_error_panic_hook"]

[dependencies]
wasm-bindgen = "0.2.63"

# The `console_error_panic_hook` crate provides better debugging of panics by
# logging them with `console.error`. This is great for development, but requires
# all the `std::fmt` and `std::panicking` infrastructure, so isn't great for
# code size when deploying.
console_error_panic_hook = { version = "0.1.6", optional = true }

# `wee_alloc` is a tiny allocator for wasm that is only ~1K in code size
# compared to the default allocator's ~10K. It is slower than the default
# allocator, however.
#
# Unfortunately, `wee_alloc` requires nightly Rust when targeting wasm for now.
wee_alloc = { version = "0.4.5", optional = true }

[dev-dependencies]
wasm-bindgen-test = "0.3.13"

[profile.release]
# Tell `rustc` to optimize for small code size.
opt-level = "s"
#+END_SRC

The src/lib.rs file is the root of the Rust crate that we are compiling to WebAssembly. It uses wasm-bindgen to interface with JavaScript.
It imports the window.alert JavaScript function and it exports the greet Rust function, which alerts a greeting message.

#+name:
#+BEGIN_SRC rust
mod utils;

use wasm_bindgen::prelude::*;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[wasm_bindgen]
extern {
    fn alert(s: &str);
}

#[wasm_bindgen]
pub fn greet() {
    alert("Hello, wasm-game-of-life!");
}
#+END_SRC

** Putting it into a Web Page

   To take our wasm-game-of-life package and use it in a web page, we use the create-wasm-app JavaScript project template.

   Run this command in the directory:

#+name:
#+BEGIN_SRC bash
npm init wasm-app www
#+END_SRC

Now we have a www folder with a bunch of generated files

#+name:
#+BEGIN_SRC bash :dir ~/Documents/exp/rust/gol/pkg/www
ls
#+END_SRC

| bootstrap.js      |
| index.html        |
| index.js          |
| LICENSE-APACHE    |
| LICENSE-MIT       |
| package.json      |
| package-lock.json |
| README.md         |
| webpack.config.js |


** Install the Dependencies

   To ensure that the local development server and its dependencies are installed, run npm install within the gol/www subdirectory

** Using our Local wasm-game-of-life package in www

   Rather than using the hello-wasm-pack from npm, we want to use our local wasm-game-of-life package instead.

   We need to open up the package.json file and next to devDependencies we want to include our entry
#+name:
#+BEGIN_SRC json :tangle gol/pkg/www/package.json
{
  "name": "create-wasm-app",
  "version": "0.1.0",
  "description": "create an app to consume rust-generated wasm packages",
  "main": "index.js",
  "bin": {
    "create-wasm-app": ".bin/create-wasm-app.js"
  },
  "scripts": {
    "build": "webpack --config webpack.config.js",
    "start": "webpack-dev-server"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rustwasm/create-wasm-app.git"
  },
  "keywords": [
    "webassembly",
    "wasm",
    "rust",
    "webpack"
  ],
  "author": "Ashley Williams <ashley666ashley@gmail.com>",
  "license": "(MIT OR Apache-2.0)",
  "bugs": {
    "url": "https://github.com/rustwasm/create-wasm-app/issues"
  },
  "homepage": "https://github.com/rustwasm/create-wasm-app#readme",
  "dependencies": {
      "wasm-game-of-life": "file:~/Documents/exp/rust/gol/pkg"
  },
  "devDependencies": {
    "hello-wasm-pack": "^0.1.0",
    "webpack": "^4.29.3",
    "webpack-cli": "^3.1.0",
    "webpack-dev-server": "^3.1.5",
    "copy-webpack-plugin": "^5.0.0"
  }
}
#+END_SRC

Next we want to modify wasm-game-of-life/www/index.js to import wasm-game-of-life instead of the hello-wasm-pack package

#+name:
#+BEGIN_SRC javascript
import * as wasm from "wasm-game-of-life";

wasm.greet("Michael");
#+END_SRC

Since we have declared a new dependency, we need to install it with npm install 

Anytime we make changes and want them reflected on localhost:8080, just rerun wasm-pack build command within the wasm-game-of-life directory

** Exercises

   Modify the greet fn in gol/src/lib.rs to take a name: &str parameter that customizes the alerted message and pass your name

#+name:
#+BEGIN_SRC rust
mod utils;

use wasm_bindgen::prelude::*;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[wasm_bindgen]
extern {
    fn alert(s: &str);
}

#[wasm_bindgen]
pub fn greet(name: &str) {
    alert(&format!("Hello, {}", name));
}
#+END_SRC

* Rules

  The Game of Life is an infinite 2D orthogonal grid of square cells, each of which is in one of two possible states: alive or dead. Every cell interacts with its eight neighbors, which are the cells that are horizontally, vertically, or diagonally adjacent.

  At each step in time, the following transitions occur:
  1. Any live cell with fewer than 2 live neighbors dies, as if caused by underpopulation
  2. Any live cell with 2 or 3 live neighbors lives on to the next generation
  3. Any live cell with more than 3 live neighbors dies, as if by overpopulation
  4. Any dead cell with exactly 3 live neighbors becomes a live cell, as if by reproduction

* Implementing Conway's Game of Life

  Since GoL is played in an infinite universe and we don't have infinite memory, we will use a workaround. We will create a fixed-size, periodic universe, where cells on the edges have neighbors that wrap around to the other side of the universe. Because neighbors wrap around the edges of the universe, gliders can keep running forever.

  
** Interfacing Rust and JavaScript

   JS's garbage collected heap - where Objects, Arrays, and DOM nodes are allocated - is distinct from WebAssembly's linear memory space, where our Rust values live. WebAssembly has no direct access to the GC Heap (maybe, this tutorial is older), but JS can read and write to the WebAssembly linear memory space, but only as an ArrayBuffer of scalar values (u8, i32, f64, etc). WebAssembly functions also take and return scalar values. These are the building blocks from which all WebAssembly and JavaScript communication is constituted.

   When designing an interface between WebAssembly and JavaScript, we want to optimize for the following properties:

   1. Minimizing copying into and out of the WebAssembly linear memory to avoid unnecessary overhead
   2. Minimizing serializing and deserializing. Serializing and Deserializing also impose overhead, and often copying as well.

   As a general rule of thumb, a good JS <- -> WebAssembly interface design is often one where large, long-lived data structures are implemented as Rust types that live in the WebAssembly linear memory, and are exposed to JavaScript as opaque handles. JS calls exported WebAssembly functions that take these opaque handles, transform their data, perform heavy computations, query the data, and ultimately return a small, copyable result .

** Interfacing Rust and JavaScript in our Game of Life

   We can represent the universe as a flat array that lives in the WebAssembly linear memory, and has a byte for each cell. 0 is a dead cell and 1 is a live cell.

   To find the array index of the cell at a given row and column in the universe, we can use this formula: index(row, column, universe) = row * width(universe) + column

   We will implement std::fmt::Display for Universe, which we can use to generate a Rust String of the cells rendered as text characters. This Rust String is then copied from the WebAssembly linear memory into a
   JavaScript String in the JavaScript's garbage collected heap, and is then displayed by setting HTML textContent. Later in the chapter, we will evolve this implementation to avoid copying the universe's cells between heaps and to render to <canvas>

** Rust Implementation

   We will modify the project template now. We begin by removing the alert import and greet function and replacing them with a type definition for cells.
   
#+BEGIN_SRC rust :tangle gol/src/lib.rs
mod utils;

use wasm_bindgen::prelude::*;
use std::fmt;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// define a Cell
#[wasm_bindgen]
#[repr(u8)] // to make sure each cell is represented as a single byte
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1, // allows us to easily count a cell's live neighbors with addition
}

// define the universe
#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec<Cell>,
}

#[wasm_bindgen]
impl Universe {
    // access a cell at a given row / column 
    fn get_index(&self, row: u32, column: u32) -> usize {
	(row * self.width + column) as usize
    }

    // get live neighbor count for seeing how many neighbors are alive
    fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {
	let mut count = 0;
	for delta_row in [self.height - 1, 0, 1].iter().cloned() {
	    for delta_col in [self.width - 1, 0, 1].iter().cloned() {
		if delta_row == 0 && delta_col == 0 {
		    continue;
		}

		let neighbor_row = (row + delta_row) % self.height;
		let neighbor_col = (column + delta_col) % self.width;
		let idx = self.get_index(neighbor_row, neighbor_col);
		count += self.cells[idx] as u8;
	    }
	}
	count
    }

    // compute the next generation from the current one
    pub fn tick(&mut self) {
	let mut next = self.cells.clone();

	for row in 0..self.height {
	    for col in 0..self.width {
	    let idx = self.get_index(row, col);
	    let cell = self.cells[idx];
	    let live_neighbors = self.live_neighbor_count(row, col);

	    let next_cell = match (cell, live_neighbors) {
		// Rule 1. Any live cell with fewer than 2 live neighbors dies
		(Cell::Alive, x) if x < 2 => Cell::Dead,
		// Rule 2. Any live cell with 2 or 3 neighbors lives
		(Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,
		// Rule 3. Any live cell with > 3 neighbors dies
		(Cell::Alive, x) if x > 3 => Cell::Dead,
		// Rule 4. Any dead cell with exactly 3 live neighbors comes to life
		(Cell::Dead, 3) => Cell::Alive,
		// All other cells remain in the same state
		(otherwise, _) => otherwise,
	    };

	    next[idx] = next_cell;
	    }
	}
	self.cells = next;
    }

    // define a constructor that initializes the Universe with an interesting pattern of live and dead cells
    pub fn new() -> Universe {
	let width = 64;
	let height = 64;

	let cells = (0..width * height)
	    .map(|i| {
		if i % 2 == 0 || i % 7 == 0 {
		    Cell::Alive
		} else {
		    Cell::Dead
		}
	    })
	    .collect();

	Universe {
	    width, height, cells,
	}
    }

    // a function to render the universe
    pub fn render(&self) -> String {
	self.to_string()
    }
}

impl fmt::Display for Universe {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
	for line in self.cells.as_slice().chunks(self.width as usize) {
	    for &cell in line {
		let symbol = if cell == Cell::Dead {'◻'} else {'◼'};
		write!(f, "{}", symbol)?;
	    }
	    write!(f, "\n")?;
	}
	Ok(())
    }
}
#+END_SRC

** Rendering with JavaScript

   Lets add a pre tag to show our universe. We also want to center align it
   
#+name:
#+BEGIN_SRC html :tangle gol/pkg/www/index.html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Hello wasm-pack!</title>
    <style>
      body {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      }
    </style>
  </head>
  <body>
    <pre id="game-of-life-canvas"></pre>
    <noscript>This page contains webassembly and javascript content, please enable javascript in your browser.</noscript>
    <script src="./bootstrap.js"></script>
  </body>
</html>
#+END_SRC

and we need to import Universe rather than greet

#+name:
#+BEGIN_SRC javascript :tangle gol/pkg/www/index.js
// import * as wasm from "wasm-game-of-life";
import { Universe } from "wasm-game-of-life";

const pre = document.getElementById("game-of-life-canvas");
const universe = Universe.new();

const renderLoop = () => {
    pre.textContent = universe.render();
    universe.tick();

    requestAnimationFrame(renderLoop);
};

requestAnimationFrame(renderLoop);

// wasm.greet("Michael");
#+END_SRC


