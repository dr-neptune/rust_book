* Rust and WebAssembly

  This tutorial implements Conway's Game of Life in Rust and WebAssembly

* Setup

  We need the Rust toolchain (rustup, rustc, and cargo)

  We also need wasm-pack, cargo-generate, nodejs, and npm
  
* Hello, World!

  First we clone the project template

#+name:
#+BEGIN_SRC bash
cargo generate --git https://github.com/rustwasm/wasm-pack-template
#+END_SRC

here is our generated Cargo.toml:

#+name:
#+BEGIN_SRC toml
[package]
name = "wasm-game-of-life"
version = "0.1.0"
authors = ["dr-neptune <mrose4@worcester.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[features]
default = ["console_error_panic_hook"]

[dependencies]
wasm-bindgen = "0.2.63"

# The `console_error_panic_hook` crate provides better debugging of panics by
# logging them with `console.error`. This is great for development, but requires
# all the `std::fmt` and `std::panicking` infrastructure, so isn't great for
# code size when deploying.
console_error_panic_hook = { version = "0.1.6", optional = true }

# `wee_alloc` is a tiny allocator for wasm that is only ~1K in code size
# compared to the default allocator's ~10K. It is slower than the default
# allocator, however.
#
# Unfortunately, `wee_alloc` requires nightly Rust when targeting wasm for now.
wee_alloc = { version = "0.4.5", optional = true }

[dev-dependencies]
wasm-bindgen-test = "0.3.13"

[profile.release]
# Tell `rustc` to optimize for small code size.
opt-level = "s"
#+END_SRC

The src/lib.rs file is the root of the Rust crate that we are compiling to WebAssembly. It uses wasm-bindgen to interface with JavaScript.
It imports the window.alert JavaScript function and it exports the greet Rust function, which alerts a greeting message.

#+name:
#+BEGIN_SRC rust
mod utils;

use wasm_bindgen::prelude::*;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[wasm_bindgen]
extern {
    fn alert(s: &str);
}

#[wasm_bindgen]
pub fn greet() {
    alert("Hello, wasm-game-of-life!");
}
#+END_SRC

** Putting it into a Web Page

   To take our wasm-game-of-life package and use it in a web page, we use the create-wasm-app JavaScript project template.

   Run this command in the directory:

#+name:
#+BEGIN_SRC bash
npm init wasm-app www
#+END_SRC

Now we have a www folder with a bunch of generated files

#+name:
#+BEGIN_SRC bash :dir ~/Documents/exp/rust/gol/pkg/www
ls
#+END_SRC

| bootstrap.js      |
| index.html        |
| index.js          |
| LICENSE-APACHE    |
| LICENSE-MIT       |
| package.json      |
| package-lock.json |
| README.md         |
| webpack.config.js |


** Install the Dependencies

   To ensure that the local development server and its dependencies are installed, run npm install within the gol/www subdirectory

** Using our Local wasm-game-of-life package in www

   Rather than using the hello-wasm-pack from npm, we want to use our local wasm-game-of-life package instead.

   We need to open up the package.json file and next to devDependencies we want to include our entry
#+name:
#+BEGIN_SRC json :tangle gol/pkg/www/package.json
{
  "name": "create-wasm-app",
  "version": "0.1.0",
  "description": "create an app to consume rust-generated wasm packages",
  "main": "index.js",
  "bin": {
    "create-wasm-app": ".bin/create-wasm-app.js"
  },
  "scripts": {
    "build": "webpack --config webpack.config.js",
    "start": "webpack-dev-server"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rustwasm/create-wasm-app.git"
  },
  "keywords": [
    "webassembly",
    "wasm",
    "rust",
    "webpack"
  ],
  "author": "Ashley Williams <ashley666ashley@gmail.com>",
  "license": "(MIT OR Apache-2.0)",
  "bugs": {
    "url": "https://github.com/rustwasm/create-wasm-app/issues"
  },
  "homepage": "https://github.com/rustwasm/create-wasm-app#readme",
  "dependencies": {
      "wasm-game-of-life": "file:~/Documents/exp/rust/gol/pkg"
  },
  "devDependencies": {
    "hello-wasm-pack": "^0.1.0",
    "webpack": "^4.29.3",
    "webpack-cli": "^3.1.0",
    "webpack-dev-server": "^3.1.5",
    "copy-webpack-plugin": "^5.0.0"
  }
}
#+END_SRC

Next we want to modify wasm-game-of-life/www/index.js to import wasm-game-of-life instead of the hello-wasm-pack package

#+name:
#+BEGIN_SRC javascript
import * as wasm from "wasm-game-of-life";

wasm.greet("Michael");
#+END_SRC

Since we have declared a new dependency, we need to install it with npm install 

Anytime we make changes and want them reflected on localhost:8080, just rerun wasm-pack build command within the wasm-game-of-life directory

** Exercises

   Modify the greet fn in gol/src/lib.rs to take a name: &str parameter that customizes the alerted message and pass your name

#+name:
#+BEGIN_SRC rust
mod utils;

use wasm_bindgen::prelude::*;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[wasm_bindgen]
extern {
    fn alert(s: &str);
}

#[wasm_bindgen]
pub fn greet(name: &str) {
    alert(&format!("Hello, {}", name));
}
#+END_SRC

* Rules

  The Game of Life is an infinite 2D orthogonal grid of square cells, each of which is in one of two possible states: alive or dead. Every cell interacts with its eight neighbors, which are the cells that are horizontally, vertically, or diagonally adjacent.

  At each step in time, the following transitions occur:
  1. Any live cell with fewer than 2 live neighbors dies, as if caused by underpopulation
  2. Any live cell with 2 or 3 live neighbors lives on to the next generation
  3. Any live cell with more than 3 live neighbors dies, as if by overpopulation
  4. Any dead cell with exactly 3 live neighbors becomes a live cell, as if by reproduction

* Implementing Conway's Game of Life

  Since GoL is played in an infinite universe and we don't have infinite memory, we will use a workaround. We will create a fixed-size, periodic universe, where cells on the edges have neighbors that wrap around to the other side of the universe. Because neighbors wrap around the edges of the universe, gliders can keep running forever.

  
** Interfacing Rust and JavaScript

   JS's garbage collected heap - where Objects, Arrays, and DOM nodes are allocated - is distinct from WebAssembly's linear memory space, where our Rust values live. WebAssembly has no direct access to the GC Heap (maybe, this tutorial is older), but JS can read and write to the WebAssembly linear memory space, but only as an ArrayBuffer of scalar values (u8, i32, f64, etc). WebAssembly functions also take and return scalar values. These are the building blocks from which all WebAssembly and JavaScript communication is constituted.

   When designing an interface between WebAssembly and JavaScript, we want to optimize for the following properties:

   1. Minimizing copying into and out of the WebAssembly linear memory to avoid unnecessary overhead
   2. Minimizing serializing and deserializing. Serializing and Deserializing also impose overhead, and often copying as well.

   As a general rule of thumb, a good JS <- -> WebAssembly interface design is often one where large, long-lived data structures are implemented as Rust types that live in the WebAssembly linear memory, and are exposed to JavaScript as opaque handles. JS calls exported WebAssembly functions that take these opaque handles, transform their data, perform heavy computations, query the data, and ultimately return a small, copyable result .

** Interfacing Rust and JavaScript in our Game of Life

   We can represent the universe as a flat array that lives in the WebAssembly linear memory, and has a byte for each cell. 0 is a dead cell and 1 is a live cell.

   To find the array index of the cell at a given row and column in the universe, we can use this formula: index(row, column, universe) = row * width(universe) + column

   We will implement std::fmt::Display for Universe, which we can use to generate a Rust String of the cells rendered as text characters. This Rust String is then copied from the WebAssembly linear memory into a
   JavaScript String in the JavaScript's garbage collected heap, and is then displayed by setting HTML textContent. Later in the chapter, we will evolve this implementation to avoid copying the universe's cells between heaps and to render to <canvas>

** Rust Implementation

   We will modify the project template now. We begin by removing the alert import and greet function and replacing them with a type definition for cells.
   
#+BEGIN_SRC rust
mod utils;

use wasm_bindgen::prelude::*;
use std::fmt;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// define a Cell
#[wasm_bindgen]
#[repr(u8)] // to make sure each cell is represented as a single byte
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1, // allows us to easily count a cell's live neighbors with addition
}

// define the universe
#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec<Cell>,
}

#[wasm_bindgen]
impl Universe {
    // access a cell at a given row / column 
    fn get_index(&self, row: u32, column: u32) -> usize {
	(row * self.width + column) as usize
    }

    // get live neighbor count for seeing how many neighbors are alive
    fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {
	let mut count = 0;
	for delta_row in [self.height - 1, 0, 1].iter().cloned() {
	    for delta_col in [self.width - 1, 0, 1].iter().cloned() {
		if delta_row == 0 && delta_col == 0 {
		    continue;
		}

		let neighbor_row = (row + delta_row) % self.height;
		let neighbor_col = (column + delta_col) % self.width;
		let idx = self.get_index(neighbor_row, neighbor_col);
		count += self.cells[idx] as u8;
	    }
	}
	count
    }

    // compute the next generation from the current one
    pub fn tick(&mut self) {
	let mut next = self.cells.clone();

	for row in 0..self.height {
	    for col in 0..self.width {
	    let idx = self.get_index(row, col);
	    let cell = self.cells[idx];
	    let live_neighbors = self.live_neighbor_count(row, col);

	    let next_cell = match (cell, live_neighbors) {
		// Rule 1. Any live cell with fewer than 2 live neighbors dies
		(Cell::Alive, x) if x < 2 => Cell::Dead,
		// Rule 2. Any live cell with 2 or 3 neighbors lives
		(Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,
		// Rule 3. Any live cell with > 3 neighbors dies
		(Cell::Alive, x) if x > 3 => Cell::Dead,
		// Rule 4. Any dead cell with exactly 3 live neighbors comes to life
		(Cell::Dead, 3) => Cell::Alive,
		// All other cells remain in the same state
		(otherwise, _) => otherwise,
	    };

	    next[idx] = next_cell;
	    }
	}
	self.cells = next;
    }

    // define a constructor that initializes the Universe with an interesting pattern of live and dead cells
    pub fn new() -> Universe {
	let width = 64;
	let height = 64;

	let cells = (0..width * height)
	    .map(|i| {
		if i % 2 == 0 || i % 7 == 0 {
		    Cell::Alive
		} else {
		    Cell::Dead
		}
	    })
	    .collect();

	Universe {
	    width, height, cells,
	}
    }

    // a function to render the universe
    pub fn render(&self) -> String {
	self.to_string()
    }
}

impl fmt::Display for Universe {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
	for line in self.cells.as_slice().chunks(self.width as usize) {
	    for &cell in line {
		let symbol = if cell == Cell::Dead {'▢'} else {'▧'};
		write!(f, "{}", symbol)?;
	    }
	    write!(f, "\n")?;
	}
	Ok(())
    }
}
#+END_SRC

** Rendering with JavaScript

   Lets add a pre tag to show our universe. We also want to center align it
   
#+name:
#+BEGIN_SRC html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Hello wasm-pack!</title>
    <style>
      body {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      }
    </style>
  </head>
  <body>
    <pre id="game-of-life-canvas"></pre>
    <noscript>This page contains webassembly and javascript content, please enable javascript in your browser.</noscript>
    <script src="./bootstrap.js"></script>
  </body>
</html>
#+END_SRC

and we need to import Universe rather than greet

#+name:
#+BEGIN_SRC javascript
// import * as wasm from "wasm-game-of-life";
import { Universe } from "wasm-game-of-life";

const pre = document.getElementById("game-of-life-canvas");
const universe = Universe.new();

const renderLoop = () => {
    pre.textContent = universe.render();
    universe.tick();

    requestAnimationFrame(renderLoop);
};

requestAnimationFrame(renderLoop);

// wasm.greet("Michael");
#+END_SRC

** Rendering to Canvas Directly from Memory

   Generating (and allocating) a String in Rust and then having wasm-bindgen convert it to a valid JavaScript string makes unnecessary copies of the universes cells. As the JavaScript code already knows the width and height of the universe and can read WebAssembly's linear memory that makes up the cells directly, we'll modify the render method to return a pointer to the start of the cells array.

   Also, instead of rendering Unicode text we'll switch to the Canvas API.

   First we'll replace the pre we added earlier with a canvas tag.
   
#+BEGIN_SRC html :tangle gol/pkg/www/index.html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Hello wasm-pack!</title>
    <style>
      body {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      }
    </style>
  </head>
  <body>
    <canvas id="game-of-life-canvas"></pre>
    <noscript>This page contains webassembly and javascript content, please enable javascript in your browser.</noscript>
    <script src="./bootstrap.js"></script>
  </body>
</html>
#+END_SRC

and then we add the getting functions to our library:

#+BEGIN_SRC rust
mod utils;

use wasm_bindgen::prelude::*;
use std::fmt;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// define a Cell
#[wasm_bindgen]
#[repr(u8)] // to make sure each cell is represented as a single byte
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1, // allows us to easily count a cell's live neighbors with addition
}

// define the universe
#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec<Cell>,
}

#[wasm_bindgen]
impl Universe {
    // access a cell at a given row / column 
    fn get_index(&self, row: u32, column: u32) -> usize {
	(row * self.width + column) as usize
    }

    // get live neighbor count for seeing how many neighbors are alive
    fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {
	let mut count = 0;
	for delta_row in [self.height - 1, 0, 1].iter().cloned() {
	    for delta_col in [self.width - 1, 0, 1].iter().cloned() {
		if delta_row == 0 && delta_col == 0 {
		    continue;
		}

		let neighbor_row = (row + delta_row) % self.height;
		let neighbor_col = (column + delta_col) % self.width;
		let idx = self.get_index(neighbor_row, neighbor_col);
		count += self.cells[idx] as u8;
	    }
	}
	count
    }

    // compute the next generation from the current one
    pub fn tick(&mut self) {
	let mut next = self.cells.clone();
	
	for row in 0..self.height {
	    for col in 0..self.width {
		let idx = self.get_index(row, col);
		let cell = self.cells[idx];
		let live_neighbors = self.live_neighbor_count(row, col);

		let next_cell = match (cell, live_neighbors) {
		    // Rule 1. Any live cell with fewer than 2 live neighbors dies
		    (Cell::Alive, x) if x < 2 => Cell::Dead,
		    // Rule 2. Any live cell with 2 or 3 neighbors lives
		    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,
		    // Rule 3. Any live cell with > 3 neighbors dies
		    (Cell::Alive, x) if x > 3 => Cell::Dead,
		    // Rule 4. Any dead cell with exactly 3 live neighbors comes to life
		    (Cell::Dead, 3) => Cell::Alive,
		    // All other cells remain in the same state
		    (otherwise, _) => otherwise,
		};

		next[idx] = next_cell;
	    }
	}
	self.cells = next;
	
    }

    // define a constructor that initializes the Universe with an interesting pattern of live and dead cells
    pub fn new() -> Universe {
	let width = 64;
	let height = 64;

	let cells = (0..width * height)
	    .map(|i| {
		if i % 2 == 0 || i % 7 == 0 {
		    Cell::Alive
		} else {
		    Cell::Dead
		}
	    })
	    .collect();

	Universe {
	    width, height, cells,
	}
    }

    // a function to render the universe
    pub fn render(&self) -> String {
	self.to_string()
    }

    // add public methods for JavaScript
    pub fn width(&self) -> u32 {
	self.width
    }

    pub fn height(&self) -> u32 {
	self.height
    }

    pub fn cells(&self) -> *const Cell {
	self.cells.as_ptr()
    }
}

impl fmt::Display for Universe {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
	for line in self.cells.as_slice().chunks(self.width as usize) {
	    for &cell in line {
		let symbol = if cell == Cell::Dead {'▢'} else {'▧'};
		write!(f, "{}", symbol)?;
	    }
	    write!(f, "\n")?;
	}
	Ok(())
    }
}
#+END_SRC


Now we can also import cell from our gol code and define some constants for rendering to canvas:

#+BEGIN_SRC javascript
import { Universe, Cell } from "wasm-game-of-life";
// import the WebAssembly memory
import { memory } from "wasm-game-of-life/wasm_game_of_life_bg";

// constants for rendering to canvas
const CELL_SIZE = 5; // px
const GRID_COLOR = "#CCCCCC";
const DEAD_COLOR = "#FFFFFF";
const ALIVE_COLOR = "#000000";

// construct the universe, and get its width and height
const universe = Universe.new();
const width = universe.width();
const height = universe.height();

// give the canvas room for all of our cells and a 1px border around each
const canvas = document.getElementById("game-of-life-canvas");
canvas.height = (CELL_SIZE + 1) * height + 1;
canvas.width = (CELL_SIZE + 1) * width + 1;

const ctx = canvas.getContext('2d');

const renderLoop = () => {
    debugger;
    universe.tick();

    drawGrid();
    drawCells();
    
    requestAnimationFrame(renderLoop);
};

// draw the grid between cells
const drawGrid = () => {
    ctx.beginPath();
    ctx.strokeStyle = GRID_COLOR;

    // vertical lines
    for (let i = 0; i <= width; i++) {
	ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);
	ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);
    }

    // horizontal lines
    for (let j = 0; j <= height; j++) {
	ctx.moveTo(0, j * (CELL_SIZE + 1) + 1);
	ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);
    }

    ctx.stroke();
};

const getIndex = (row, column) => {
    return row * width + column;
};

const drawCells = () => {
    const cellsPtr = universe.cells();
    const cells = new Uint8Array(memory.buffer, cellsPtr, width * height);

    ctx.beginPath();

    for (let row = 0; row < height; row++) {
	for (let col = 0; col < width; col++) {
	    const idx = getIndex(row, col);

	    ctx.fillStyle = cells[idx] == Cell.Dead
		? DEAD_COLOR
	        : ALIVE_COLOR;

	    ctx.fillRect(
		col * (CELL_SIZE + 1) + 1,
		row * (CELL_SIZE + 1) + 1,
		CELL_SIZE,
		CELL_SIZE
	    );
	}
    }
    ctx.stroke();
}

// start the rendering process
drawGrid();
drawCells();
requestAnimationFrame(renderLoop);

// wasm.greet("Michael");
#+END_SRC

** Exercises

** Initialize the universe with a single space ship

#+BEGIN_SRC rust 
mod utils;

use wasm_bindgen::prelude::*;
use std::fmt;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// define a Cell
#[wasm_bindgen]
#[repr(u8)] // to make sure each cell is represented as a single byte
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1, // allows us to easily count a cell's live neighbors with addition
}

// define the universe
#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec<Cell>,
}

#[wasm_bindgen]
impl Universe {
    // access a cell at a given row / column 
    fn get_index(&self, row: u32, column: u32) -> usize {
	(row * self.width + column) as usize
    }

    // get live neighbor count for seeing how many neighbors are alive
    fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {
	let mut count = 0;
	for delta_row in [self.height - 1, 0, 1].iter().cloned() {
	    for delta_col in [self.width - 1, 0, 1].iter().cloned() {
		if delta_row == 0 && delta_col == 0 {
		    continue;
		}

		let neighbor_row = (row + delta_row) % self.height;
		let neighbor_col = (column + delta_col) % self.width;
		let idx = self.get_index(neighbor_row, neighbor_col);
		count += self.cells[idx] as u8;
	    }
	}
	count
    }

    // compute the next generation from the current one
    pub fn tick(&mut self) {
	let mut next = self.cells.clone();
	
	for row in 0..self.height {
	    for col in 0..self.width {
	    let idx = self.get_index(row, col);
	    let cell = self.cells[idx];
	    let live_neighbors = self.live_neighbor_count(row, col);

	    let next_cell = match (cell, live_neighbors) {
		// Rule 1. Any live cell with fewer than 2 live neighbors dies
		(Cell::Alive, x) if x < 2 => Cell::Dead,
		// Rule 2. Any live cell with 2 or 3 neighbors lives
		(Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,
		// Rule 3. Any live cell with > 3 neighbors dies
		(Cell::Alive, x) if x > 3 => Cell::Dead,
		// Rule 4. Any dead cell with exactly 3 live neighbors comes to life
		(Cell::Dead, 3) => Cell::Alive,
		// All other cells remain in the same state
		(otherwise, _) => otherwise,
	    };

	    next[idx] = next_cell;
	    }
	}
	self.cells = next;
	
    }

    // define a constructor that initializes the Universe with an interesting pattern of live and dead cells
    pub fn new() -> Universe {
	let width = 64;
	let height = 64;

	// let cells = (0..width * height)
	//     .map(|i| {
	// 	if i % 2 == 0 || i % 7 == 0 {
	// 	    Cell::Alive
	// 	} else {
	// 	    Cell::Dead
	// 	}
	//     })
	//     .collect();

	let cells = (0..width * height)
	    .map(|i| {
		// if i == 130 || i == 66 || i == 194 {
		// if i == 131 || i == 66 || i == 195 || i == 194 || i == 193 || 
		//     i == 131 * 5 || i == 66 * 5 || i == 195 * 5 || i == 194 * 5 || i == 193 * 5
		if
		    // // crab!
		    // i == 66 || i == 130 || i == 193 || i == 195 || i == 258 || i == 322 ||
		    // i == 79 || i == 143 || i == 206 || i == 208 || i == 271 || i == 335 ||
		    // i == 387 || i == 391 || i == 392 || i == 393 || i == 394 || i == 398 ||
		    // i == 455 || i == 456 || i == 457 || i == 458 ||
		    // i == 515 || i == 516 || i == 517 || i == 518 || i == 523 || i == 524 || i == 525 || i == 526 ||
		    // i == 645 || i == 652 ||
		    // i == 710 || i == 711 || i == 714 || i == 715
		    // centered crab
		    i == 91 || i == 155 || i == 218 || i == 220 || i == 283 || i == 347 ||
		    i == 104 || i == 168 || i == 231 || i == 233 || i == 296 || i == 360 ||
		    i == 412 || i == 416 || i == 417 || i == 418 || i == 419 || i == 423 ||
		    i == 480 || i == 481 || i == 482 || i == 483 ||
		    i == 540 || i == 541 || i == 542 || i == 543 || i == 548 || i == 549 || i == 550 || i == 551 ||
		    i == 670 || i == 677 ||
		    i == 735 || i == 736 || i == 739 || i == 740
		{
		    Cell::Alive
		} else {
		    Cell::Dead
		}
	    })
	    .collect();
	// let cells = vec![0, width + 1, 2 * width];

	Universe {
	    width, height, cells,
	}
    }

    // a function to render the universe
    pub fn render(&self) -> String {
	self.to_string()
    }

    // add public methods for JavaScript
    pub fn width(&self) -> u32 {
	self.width
    }

    pub fn height(&self) -> u32 {
	self.height
    }

    pub fn cells(&self) -> *const Cell {
	self.cells.as_ptr()
    }
}

impl fmt::Display for Universe {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
	for line in self.cells.as_slice().chunks(self.width as usize) {
	    for &cell in line {
		let symbol = if cell == Cell::Dead {'▢'} else {'▧'};
		write!(f, "{}", symbol)?;
	    }
	    write!(f, "\n")?;
	}
	Ok(())
    }
}
#+END_SRC   

** Instead of hard coding the initial universe, generate a random one, where each cell has a 50/50 chance of being alive or dead

   We could update our toml to use the js-sys crate that imports the Math.random JavaScript function

#+name:
#+BEGIN_SRC rust 
[package]
name = "wasm-game-of-life"
version = "0.1.0"
authors = ["dr-neptune <mrose4@worcester.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[features]
default = ["console_error_panic_hook"]

[dependencies]
wasm-bindgen = "0.2.63"
js-sys = "0.3"
    
# The `console_error_panic_hook` crate provides better debugging of panics by
# logging them with `console.error`. This is great for development, but requires
# all the `std::fmt` and `std::panicking` infrastructure, so isn't great for
# code size when deploying.
console_error_panic_hook = { version = "0.1.6", optional = true }

# `wee_alloc` is a tiny allocator for wasm that is only ~1K in code size
# compared to the default allocator's ~10K. It is slower than the default
# allocator, however.
#
# Unfortunately, `wee_alloc` requires nightly Rust when targeting wasm for now.
wee_alloc = { version = "0.4.5", optional = true }

[dev-dependencies]
wasm-bindgen-test = "0.3.13"

[profile.release]
# Tell `rustc` to optimize for small code size.
opt-level = "s"
#+END_SRC

Then we could call the js_sys::Math::random function to flip a coin

#+BEGIN_SRC rust
mod utils;

use wasm_bindgen::prelude::*;
use std::fmt;

extern crate js_sys;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// define a Cell
#[wasm_bindgen]
#[repr(u8)] // to make sure each cell is represented as a single byte
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1, // allows us to easily count a cell's live neighbors with addition
}

// define the universe
#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec<Cell>,
}

#[wasm_bindgen]
impl Universe {
    // access a cell at a given row / column 
    fn get_index(&self, row: u32, column: u32) -> usize {
	(row * self.width + column) as usize
    }

    // get live neighbor count for seeing how many neighbors are alive
    fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {
	let mut count = 0;
	for delta_row in [self.height - 1, 0, 1].iter().cloned() {
	    for delta_col in [self.width - 1, 0, 1].iter().cloned() {
		if delta_row == 0 && delta_col == 0 {
		    continue;
		}

		let neighbor_row = (row + delta_row) % self.height;
		let neighbor_col = (column + delta_col) % self.width;
		let idx = self.get_index(neighbor_row, neighbor_col);
		count += self.cells[idx] as u8;
	    }
	}
	count
    }

    // compute the next generation from the current one
    pub fn tick(&mut self) {
	let mut next = self.cells.clone();
	
	for row in 0..self.height {
	    for col in 0..self.width {
	    let idx = self.get_index(row, col);
	    let cell = self.cells[idx];
	    let live_neighbors = self.live_neighbor_count(row, col);

	    let next_cell = match (cell, live_neighbors) {
		// Rule 1. Any live cell with fewer than 2 live neighbors dies
		(Cell::Alive, x) if x < 2 => Cell::Dead,
		// Rule 2. Any live cell with 2 or 3 neighbors lives
		(Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,
		// Rule 3. Any live cell with > 3 neighbors dies
		(Cell::Alive, x) if x > 3 => Cell::Dead,
		// Rule 4. Any dead cell with exactly 3 live neighbors comes to life
		(Cell::Dead, 3) => Cell::Alive,
		// All other cells remain in the same state
		(otherwise, _) => otherwise,
	    };

	    next[idx] = next_cell;
	    }
	}
	self.cells = next;
	
    }

    // define a constructor that initializes the Universe with an interesting pattern of live and dead cells
    pub fn new() -> Universe {
	let width = 64;
	let height = 64;

	// let cells = (0..width * height)
	//     .map(|i| {
	// 	if i % 2 == 0 || i % 7 == 0 {
	// 	    Cell::Alive
	// 	} else {
	// 	    Cell::Dead
	// 	}
	//     })
	//     .collect();

	let cells = (0..width * height)
	    .map(|i| {
		// if i == 130 || i == 66 || i == 194 {
		// if i == 131 || i == 66 || i == 195 || i == 194 || i == 193 || 
		//     i == 131 * 5 || i == 66 * 5 || i == 195 * 5 || i == 194 * 5 || i == 193 * 5
		if
		    // // crab!
		    // i == 66 || i == 130 || i == 193 || i == 195 || i == 258 || i == 322 ||
		    // i == 79 || i == 143 || i == 206 || i == 208 || i == 271 || i == 335 ||
		    // i == 387 || i == 391 || i == 392 || i == 393 || i == 394 || i == 398 ||
		    // i == 455 || i == 456 || i == 457 || i == 458 ||
		    // i == 515 || i == 516 || i == 517 || i == 518 || i == 523 || i == 524 || i == 525 || i == 526 ||
		    // i == 645 || i == 652 ||
		    // i == 710 || i == 711 || i == 714 || i == 715
		    // centered crab
		    // i == 91 || i == 155 || i == 218 || i == 220 || i == 283 || i == 347 ||
		    // i == 104 || i == 168 || i == 231 || i == 233 || i == 296 || i == 360 ||
		    // i == 412 || i == 416 || i == 417 || i == 418 || i == 419 || i == 423 ||
		    // i == 480 || i == 481 || i == 482 || i == 483 ||
		    // i == 540 || i == 541 || i == 542 || i == 543 || i == 548 || i == 549 || i == 550 || i == 551 ||
		    // i == 670 || i == 677 ||
		// i == 735 || i == 736 || i == 739 || i == 740
		    js_sys::Math::random() < 0.5 
		{
		    Cell::Alive
		} else {
		    Cell::Dead
		}
	    })
	    .collect();
	// let cells = vec![0, width + 1, 2 * width];

	Universe {
	    width, height, cells,
	}
    }

    // a function to render the universe
    pub fn render(&self) -> String {
	self.to_string()
    }

    // add public methods for JavaScript
    pub fn width(&self) -> u32 {
	self.width
    }

    pub fn height(&self) -> u32 {
	self.height
    }

    pub fn cells(&self) -> *const Cell {
	self.cells.as_ptr()
    }
}

impl fmt::Display for Universe {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
	for line in self.cells.as_slice().chunks(self.width as usize) {
	    for &cell in line {
		let symbol = if cell == Cell::Dead {'▢'} else {'▧'};
		write!(f, "{}", symbol)?;
	    }
	    write!(f, "\n")?;
	}
	Ok(())
    }
}
#+END_SRC

** Representing each cell with a byte makes iterating over cells easy, but it comes at the cost of wasting memory.
   Each byte is eight bits, but we only require a single bit to represent whether each cell is alive or dead.
   Refactor the data representation so that each cell uses only a single bit of space.
   

   We can use the fixedbitset crate and its FixedBitSet type to represent cells instead of Vec<Cell>:
   
#+name:
#+BEGIN_SRC rust
[package]
name = "wasm-game-of-life"
version = "0.1.0"
authors = ["dr-neptune <mrose4@worcester.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[features]
default = ["console_error_panic_hook"]

[dependencies]
wasm-bindgen = "0.2.63"
js-sys = "0.3"
fixedbitset = "0.3.2"
    
# The `console_error_panic_hook` crate provides better debugging of panics by
# logging them with `console.error`. This is great for development, but requires
# all the `std::fmt` and `std::panicking` infrastructure, so isn't great for
# code size when deploying.
console_error_panic_hook = { version = "0.1.6", optional = true }

# `wee_alloc` is a tiny allocator for wasm that is only ~1K in code size
# compared to the default allocator's ~10K. It is slower than the default
# allocator, however.
#
# Unfortunately, `wee_alloc` requires nightly Rust when targeting wasm for now.
wee_alloc = { version = "0.4.5", optional = true }

[dev-dependencies]
wasm-bindgen-test = "0.3.13"

[profile.release]
# Tell `rustc` to optimize for small code size.
opt-level = "s"
#+END_SRC


#+BEGIN_SRC rust
mod utils;

use wasm_bindgen::prelude::*;
use std::fmt;

extern crate js_sys;
extern crate fixedbitset;
use fixedbitset::FixedBitSet;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// define a Cell
#[wasm_bindgen]
#[repr(u8)] // to make sure each cell is represented as a single byte
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1, // allows us to easily count a cell's live neighbors with addition
}

// define the universe
#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: FixedBitSet,
}

#[wasm_bindgen]
impl Universe {
    // access a cell at a given row / column 
    fn get_index(&self, row: u32, column: u32) -> usize {
	(row * self.width + column) as usize
    }

    // get live neighbor count for seeing how many neighbors are alive
    fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {
	let mut count = 0;
	for delta_row in [self.height - 1, 0, 1].iter().cloned() {
	    for delta_col in [self.width - 1, 0, 1].iter().cloned() {
		if delta_row == 0 && delta_col == 0 {
		    continue;
		}

		let neighbor_row = (row + delta_row) % self.height;
		let neighbor_col = (column + delta_col) % self.width;
		let idx = self.get_index(neighbor_row, neighbor_col);
		count += self.cells[idx] as u8;
	    }
	}
	count
    }

    // compute the next generation from the current one
    pub fn tick(&mut self) {
	let mut next = self.cells.clone();
	
	for row in 0..self.height {
	    for col in 0..self.width {
		let idx = self.get_index(row, col);
		let cell = self.cells[idx];
		let live_neighbors = self.live_neighbor_count(row, col);

		next.set(idx, match (cell, live_neighbors) {
		    (true, x) if x < 2 => false,
		    (true, 2) | (true, 3) => true,
		    (true, x) if x > 3 => false,
		    (false, 3) => true,
		    (otherwise, _) => otherwise
		});
		
		// let next_cell = match (cell, live_neighbors) {
		//     // Rule 1. Any live cell with fewer than 2 live neighbors dies
		//     (Cell::Alive, x) if x < 2 => Cell::Dead,
		//     // Rule 2. Any live cell with 2 or 3 neighbors lives
		//     (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,
		//     // Rule 3. Any live cell with > 3 neighbors dies
		//     (Cell::Alive, x) if x > 3 => Cell::Dead,
		//     // Rule 4. Any dead cell with exactly 3 live neighbors comes to life
		//     (Cell::Dead, 3) => Cell::Alive,
		//     // All other cells remain in the same state
		//     (otherwise, _) => otherwise,
		// };
		
		// next[idx] = next_cell;
	    }
	}
	// self.cells = next;
    }

    // define a constructor that initializes the Universe with an interesting pattern of live and dead cells
    pub fn new() -> Universe {
	let width = 64;
	let height = 64;

	let size = (width * height) as usize;
	let mut cells = FixedBitSet::with_capacity(size);

	for i in 0..size {
	    // cells.set(i, js_sys::Math::random() < 0.5);
	    cells.set(i, i % 2 == 0 || i % 7 == 0);
	}
	
	// let cells = (0..width * height)
	//     .map(|i| {
	// 	if
	// 	    js_sys::Math::random() < 0.5 
	// 	{
	// 	    Cell::Alive
	// 	} else {
	// 	    Cell::Dead
	// 	}
	//     })
	//     .collect();
	// // let cells = vec![0, width + 1, 2 * width];

	Universe {
	    width, height, cells,
	}
    }

    // a function to render the universe
    pub fn render(&self) -> String {
	self.to_string()
    }

    // add public methods for JavaScript
    pub fn width(&self) -> u32 {
	self.width
    }

    pub fn height(&self) -> u32 {
	self.height
    }

    pub fn cells(&self) -> *const u32 {
	self.cells.as_slice().as_ptr()
    }
}

impl fmt::Display for Universe {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
	// for line in self.cells.as_slice().chunks(self.width as usize) {
	//     for &cell in line {
	// 	let symbol = if cell == Cell::Dead {'▢'} else {'▧'};
	// 	write!(f, "{}", symbol)?;
	//     }
	//     write!(f, "\n")?;
	// }
	Ok(())
    }
}
#+END_SRC

We also need to update javascript. Constructing a Uint8Array from WASM memory is the same as before, except the length of the array is not width * height anymore, but width * height / 8 since we have a cell per bit rather than per byte.

#+BEGIN_SRC javascript
import { Universe, Cell } from "wasm-game-of-life";
// import the WebAssembly memory
import { memory } from "wasm-game-of-life/wasm_game_of_life_bg";

// constants for rendering to canvas
const CELL_SIZE = 5; // px
const GRID_COLOR = "#CCCCCC";
const DEAD_COLOR = "#FFFFFF";
const ALIVE_COLOR = "#000000";

// construct the universe, and get its width and height
const universe = Universe.new();
const width = universe.width();
const height = universe.height();

// give the canvas room for all of our cells and a 1px border around each
const canvas = document.getElementById("game-of-life-canvas");
canvas.height = (CELL_SIZE + 1) * height + 1;
canvas.width = (CELL_SIZE + 1) * width + 1;

const ctx = canvas.getContext('2d');

const renderLoop = () => {
    debugger;
    universe.tick();

    drawGrid();
    drawCells();
    
    requestAnimationFrame(renderLoop);
};

// draw the grid between cells
const drawGrid = () => {
    ctx.beginPath();
    ctx.strokeStyle = GRID_COLOR;

    // vertical lines
    for (let i = 0; i <= width; i++) {
	ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);
	ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);
    }

    // horizontal lines
    for (let j = 0; j <= height; j++) {
	ctx.moveTo(0, j * (CELL_SIZE + 1) + 1);
	ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);
    }

    ctx.stroke();
};

const getIndex = (row, column) => {
    return row * width + column;
};

// determine whether the nth bit is set
const  bitIsSet = (n, arr) => {
    const byte = Math.floor(n / 8);
    const mask = 1 << (n % 8);
    return (arr[byte] & mask) === mask;
};

const drawCells = () => {
    const cellsPtr = universe.cells();

    const cells = new Uint8Array(memory.bugger, cellsPtr, width * height / 8);

    ctx.beginPath();

    for (let row = 0; row < height; row++) {
	for (let col = 0; col < width; col++) {
	    const idx = getIndex(row, col);

	    ctx.fillStyle = cells[idx] == Cell.Dead
		? DEAD_COLOR
	        : ALIVE_COLOR;

	    ctx.fillRect(
		col * (CELL_SIZE + 1) + 1,
		row * (CELL_SIZE + 1) + 1,
		CELL_SIZE,
		CELL_SIZE
	    );
	}
    }
    ctx.stroke();    
}

// const drawCells = () => {
//     const cellsPtr = universe.cells();
//     const cells = new Uint8Array(memory.buffer, cellsPtr, width * height / 8);

//     ctx.beginPath();

//     for (let row = 0; row < height; row++) {
// 	for (let col = 0; col < width; col++) {
// 	    const idx = getIndex(row, col);

// 	    ctx.fillStyle = cells[idx] == Cell.Dead
// 		? DEAD_COLOR
// 	        : ALIVE_COLOR;

// 	    ctx.fillRect(
// 		col * (CELL_SIZE + 1) + 1,
// 		row * (CELL_SIZE + 1) + 1,
// 		CELL_SIZE,
// 		CELL_SIZE
// 	    );
// 	}
//     }
//     ctx.stroke();
// }



// start the rendering process
drawGrid();
drawCells();
requestAnimationFrame(renderLoop);

// wasm.greet("Michael");
#+END_SRC

* Testing Conway's Game of Life

  We are going to test our tick function to make sure that it gives us the output that we expect.

  First we will want to create some getter and setter functions inside our existing impl Universe block.
  We are going to create a set_width and set_height function so we can create Universes of different sizes.
  
#+BEGIN_SRC rust  :tangle gol/src/lib.rs
mod utils;

use wasm_bindgen::prelude::*;
use std::fmt;

extern crate web_sys;

macro_rules! log {
    ( $( $t:tt )* ) => {
	web_sys::console::log_1(&format!( $( $t )* ).into());
    }
}

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// define a Cell
#[wasm_bindgen]
#[repr(u8)] // to make sure each cell is represented as a single byte
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1, // allows us to easily count a cell's live neighbors with addition
}

// define the universe
#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec<Cell>,
}

#[wasm_bindgen]
impl Universe {
    // access a cell at a given row / column 
    fn get_index(&self, row: u32, column: u32) -> usize {
	(row * self.width + column) as usize
    }

    // sets the width of the universe
    // resets all cells to the dead state
    pub fn set_width(&mut self, width: u32) {
	self.width = width;
	self.cells = (0..width * self.height).map(|_i| Cell::Dead).collect();
    }

    pub fn set_height(&mut self, height: u32) {
	self.height = height;
	self.cells = (0..self.width * height).map(|_i| Cell::Dead).collect();
    }
    
    // get live neighbor count for seeing how many neighbors are alive
    fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {
	let mut count = 0;
	for delta_row in [self.height - 1, 0, 1].iter().cloned() {
	    for delta_col in [self.width - 1, 0, 1].iter().cloned() {
		if delta_row == 0 && delta_col == 0 {
		    continue;
		}

		let neighbor_row = (row + delta_row) % self.height;
		let neighbor_col = (column + delta_col) % self.width;
		let idx = self.get_index(neighbor_row, neighbor_col);
		count += self.cells[idx] as u8;
	    }
	}
	count
    }

    // compute the next generation from the current one
    pub fn tick(&mut self) {
	let mut next = self.cells.clone();
	
	for row in 0..self.height {
	    for col in 0..self.width {
		let idx = self.get_index(row, col);
		let cell = self.cells[idx];
		let live_neighbors = self.live_neighbor_count(row, col);
		
		log!("cell[{}, {}] is initially {:?} and has {} live neighbors", row, col, cell, live_neighbors);
		
		let next_cell = match (cell, live_neighbors) {
		    // Rule 1. Any live cell with fewer than 2 live neighbors dies
		    (Cell::Alive, x) if x < 2 => Cell::Dead,
		    // Rule 2. Any live cell with 2 or 3 neighbors lives
		    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,
		    // Rule 3. Any live cell with > 3 neighbors dies
		    (Cell::Alive, x) if x > 3 => Cell::Dead,
		    // Rule 4. Any dead cell with exactly 3 live neighbors comes to life
		    (Cell::Dead, 3) => Cell::Alive,
		    // All other cells remain in the same state
		    (otherwise, _) => otherwise,
		};

		log!("it becomes {:?}", next_cell);
		
		next[idx] = next_cell;
	    }
	}
	self.cells = next;
    }

    // define a constructor that initializes the Universe with an interesting pattern of live and dead cells
    pub fn new() -> Universe {
	utils::set_panic_hook();
	
	let width = 64;
	let height = 64;

	let cells = (0..width * height)
	    .map(|i| {
		if i % 2 == 0 || i % 7 == 0 {
		    Cell::Alive
		} else {
		    Cell::Dead
		}
	    })
	    .collect();

	Universe {
	    width, height, cells,
	}
    }

    // a function to render the universe
    pub fn render(&self) -> String {
	self.to_string()
    }

    // add public methods for JavaScript
    pub fn width(&self) -> u32 {
	self.width
    }

    pub fn height(&self) -> u32 {
	self.height
    }

    pub fn cells(&self) -> *const Cell {
	self.cells.as_ptr()
    }
}

// add another impl Universe but don't expose it to WebAssembly
// this will be strictly for testing
impl Universe {
    // get the dead and alive attributes of the entire universe
    pub fn get_cells(&self) -> &[Cell] {
	&self.cells
    }

    // set cells to be alive in a universe by passing the row and column of each cell as an array
    pub fn set_cells(&mut self, cells: &[(u32, u32)]) {
	for (row, col) in cells.iter().cloned() {
	    let idx = self.get_index(row, col);
	    self.cells[idx] = Cell::Alive;
	}
    }
}

impl fmt::Display for Universe {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
	for line in self.cells.as_slice().chunks(self.width as usize) {
	    for &cell in line {
		let symbol = if cell == Cell::Dead {'▢'} else {'▧'};
		write!(f, "{}", symbol)?;
	    }
	    write!(f, "\n")?;
	}
	Ok(())
    }
}
#+END_SRC

Next we will create our test in the wasm_game_of_life/tests/web.rs file.

#+name:
#+BEGIN_SRC rust :tangle gol/tests/web.rs
//! Test suite for the Web and headless browsers.

#![cfg(target_arch = "wasm32")]

extern crate wasm_bindgen_test;
use wasm_bindgen_test::*;

extern crate wasm_game_of_life;
use wasm_game_of_life::Universe;

wasm_bindgen_test_configure!(run_in_browser);

#[wasm_bindgen_test]
fn pass() {
    assert_eq!(1 + 1, 2);
}

// create some spaceship builder functions
#[cfg(test)]
pub fn input_spaceship() -> Universe {
    let mut universe = Universe::new();
    universe.set_width(6);
    universe.set_height(6);
    universe.set_cells(&[(1, 2), (2, 3), (3, 1), (3, 2), (3, 3)]);
    universe
}

#[cfg(test)]
pub fn expected_spaceship() -> Universe {
    let mut universe = Universe::new();
    universe.set_width(6);
    universe.set_height(6);
    universe.set_cells(&[(2, 1), (2, 3), (3, 2), (3, 3), (4, 2)]);
    universe    
}

// test tick
#[wasm_bindgen_test]
pub fn test_tick() {
    // create a smaller universe with a small spaceship to test
    let mut input_universe = input_spaceship();

    // this is what we expect our spaceship to look like after one tick in our universe
    let expected_universe = expected_spaceship();

    // call tick to see if the cells in the universes are the same
    input_universe.tick();
    assert_eq!(&input_universe.get_cells(),
	       &expected_universe.get_cells());
}
#+END_SRC

* Debugging

  First we want to enable logging for panics. If our code panics, we want informative error messages to appear in the developer console.

  Our template comes with an optional, enabled by default dependency on the console_error_panic_hook crate.

#+name:
#+BEGIN_SRC rust 
pub fn set_panic_hook() {
    // When the `console_error_panic_hook` feature is enabled, we can call the
    // `set_panic_hook` function at least once during initialization, and then
    // we will get better error messages if our code ever panics.
    //
    // For more details see
    // https://github.com/rustwasm/console_error_panic_hook#readme
    #[cfg(feature = "console_error_panic_hook")]
    console_error_panic_hook::set_once();
}
#+END_SRC

All we need to do is call it inside of the Universe::new constructor. I added it above in lib.rs

** Adding Logging to our GoL

   We can use the console.log function via the web-sys crate to add some logging about each cell in our Universe::tick fn.

   First we add web-sys as a dependency and enable its console feature

#+BEGIN_SRC toml :tangle gol/Cargo.toml
[package]
name = "wasm-game-of-life"
version = "0.1.0"
authors = ["dr-neptune <mrose4@worcester.edu>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[features]
default = ["console_error_panic_hook"]

[dependencies]
wasm-bindgen = "0.2.63"

# The `console_error_panic_hook` crate provides better debugging of panics by
# logging them with `console.error`. This is great for development, but requires
# all the `std::fmt` and `std::panicking` infrastructure, so isn't great for
# code size when deploying.
console_error_panic_hook = { version = "0.1.6", optional = true }

# `wee_alloc` is a tiny allocator for wasm that is only ~1K in code size
# compared to the default allocator's ~10K. It is slower than the default
# allocator, however.
#
# Unfortunately, `wee_alloc` requires nightly Rust when targeting wasm for now.
wee_alloc = { version = "0.4.5", optional = true }

[dependencies.web-sys]
version = "0.3"
features = [ "console", ]

[dev-dependencies]
wasm-bindgen-test = "0.3.13"

[profile.release]
# Tell `rustc` to optimize for small code size.
opt-level = "s"
#+END_SRC   

Now we can add the console.log function as a println! style macro

#+name:
#+BEGIN_SRC rust
extern crate web_sys;

macro_rules! log {
    ( $( $t:tt )* ) => {
	web_sys::console::log_1(&format!( $( $t )* ).into());
    }
}
#+END_SRC

* Adding Interactivity

  We will enable users to toggle whether a cell is alive or dead by clicking on it, and allow pausing the game which makes drawing cell patterns a lot easier.

** Pausing and Resuming the Game

#+name:
#+BEGIN_SRC html :tangle gol/pkg/www/index.html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Hello wasm-pack!</title>
    <style>
      body {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      }
    </style>
  </head>
  <body>
    <!-- add a play / pause button -->
    <button id="play-pause"></button>
    <canvas id="game-of-life-canvas"></pre>
    <noscript>This page contains webassembly and javascript content, please enable javascript in your browser.</noscript>
    <script src="./bootstrap.js"></script>
  </body>
</html>
#+END_SRC

#+BEGIN_SRC javascript :tangle gol/pkg/www/index.js
import { Universe, Cell } from "wasm-game-of-life";
// import the WebAssembly memory
import { memory } from "wasm-game-of-life/wasm_game_of_life_bg";

// constants for rendering to canvas
const CELL_SIZE = 5; // px
const GRID_COLOR = "#CCCCCC";
const DEAD_COLOR = "#FFFFFF";
const ALIVE_COLOR = "#000000";

// construct the universe, and get its width and height
const universe = Universe.new();
const width = universe.width();
const height = universe.height();

// give the canvas room for all of our cells and a 1px border around each
const canvas = document.getElementById("game-of-life-canvas");
canvas.height = (CELL_SIZE + 1) * height + 1;
canvas.width = (CELL_SIZE + 1) * width + 1;

const ctx = canvas.getContext('2d');

let animationId = null;

const renderLoop = () => {
    drawGrid();
    drawCells();
    universe.tick();
    animationId = requestAnimationFrame(renderLoop);
};

const isPaused = () => {
    return animationId === null;
};

// draw the grid between cells
const drawGrid = () => {
    ctx.beginPath();
    ctx.strokeStyle = GRID_COLOR;

    // vertical lines
    for (let i = 0; i <= width; i++) {
	ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);
	ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);
    }

    // horizontal lines
    for (let j = 0; j <= height; j++) {
	ctx.moveTo(0, j * (CELL_SIZE + 1) + 1);
	ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);
    }

    ctx.stroke();
};

const getIndex = (row, column) => {
    return row * width + column;
};

const drawCells = () => {
    const cellsPtr = universe.cells();
    const cells = new Uint8Array(memory.buffer, cellsPtr, width * height);

    ctx.beginPath();

    for (let row = 0; row < height; row++) {
	for (let col = 0; col < width; col++) {
	    const idx = getIndex(row, col);

	    ctx.fillStyle = cells[idx] == Cell.Dead
		? DEAD_COLOR
	        : ALIVE_COLOR;

	    ctx.fillRect(
		col * (CELL_SIZE + 1) + 1,
		row * (CELL_SIZE + 1) + 1,
		CELL_SIZE,
		CELL_SIZE
	    );
	}
    }
    ctx.stroke();
}

// start the rendering process
drawGrid();
drawCells();
requestAnimationFrame(renderLoop);

// wasm.greet("Michael");
#+END_SRC
