* What is a Bloom Filter?

From wikipedia:

A **Bloom Filter** is a space-efficient probabilistic data structure that is used to test whether an element is a member of a set.

First we make a new project

#+BEGIN_SRC sh
cargo new bloom_filter
#+END_SRC

and add bit vectors as a dependency:

#+BEGIN_SRC toml :tangle bloom_filter/Cargo.toml
[package]
name = "bloom_filter"
version = "0.1.0"
authors = ["dr-neptune <mrose4@worcester.edu>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
bit-vec = "0.6"
#+END_SRC

then rebuild

#+BEGIN_SRC sh :dir bloom_filter
cargo build
#+END_SRC

Next we declare a new struct to encapsulate required fields:
- $k$ optimal number of hash functions
- $m$ optimal size of the bit array
- $v$ the bit array
- hash functions
- a marker to tell the rust compiler that our struct owns a T

#+name: preamble-struct
#+BEGIN_SRC rust :crates '((bit-vec . "0.6"))
extern crate bit_vec;

use bit_vec::BitVec;
use std::collections::hash_map::{DefaultHasher, RandomState};
use std::hash::{BuildHasher, Hash, Hasher};
use std::marker::PhantomData;

pub struct StandardBloomFilter<T: ?Sized> {
    bitmap: BitVec,
    optimal_m: u64,
    optimal_k: u32,
    hashers: [DefaultHasher; 2],
    _marker: PhantomData<T>,
}
#+END_SRC

The Bloom filter has two operations: Insert and Query. We will implement those two operations along with a constructor-like new method:

#+name: new-constructor
#+BEGIN_SRC rust
// new calculates the size of the bitmap v and optimal_k k and then instantiates a StandardBloomFilter
pub fn new(items_count: usize, fp_rate: f64) -> Self {
    // get optimals and instantiate hash functions
    let optimal_m = Self::bitmap_size(items_count, fp_rate);
    let optimal_k = Self::optimal_k(fp_rate);
    let hashers = [
	RandomState::new().build_hasher(),
	RandomState::new().build_hasher(),
    ];
    // instantiate the bloom filter
    StandardBloomFilter {
	bitmap: BitVec::from_elem(optimal_m as usize, false),
	optimal_m,
	optimal_k,
	hashers,
	_marker: PhantomData,
    }
}
#+END_SRC

#+name: bitmap-size
#+BEGIN_SRC rust
// Calculate the size of bitmap
// The size of bitmap depends on the target false positive probability and # of items in the set
fn bitmap_size(items_count: usize, fp_rate: f64) -> usize {
    let ln2_2 = core::f64::consts::LN_2 * core::f64::consts::LN_2;
    ((-1.0f64 * items_count as f64 * fp_rate.ln()) / ln2_2).ceil() as usize
}
#+END_SRC

#+name: num-hash-fns
#+BEGIN_SRC rust
// calculate the number of hash functions
// This only depends on the target false positive probability
fn optimal_k(fp_rate: f64) -> u32 {
    ((-1.0f64 * fp_rate.ln()) / core::f64::consts::LN_2).ceil() as u32
}
#+END_SRC

#+BEGIN_SRC rust :tangle example2.rs :noweb yes
<<preamble-struct>>

impl<T: ?Sized> StandardBloomFilter<T> {
    // new calculates the size of the bitmap v and optimal_k k and then instantiates a StandardBloomFilter
    <<new-constructor>>

    // Calculate the size of bitmap
    // The size of bitmap depends on the target false positive probability and # of items in the set
    <<bitmap-size>>
    
    // calculate the number of hash functions
    // This only depends on the target false positive probability
    <<num-hash-fns>>
}
#+END_SRC

We can run these calculations independently:

#+BEGIN_SRC rust :results verbatim
fn main() {
    let items_count = 1_000_000;
    let bitmap_size = bitmap_size(items_count, 0.01);
    let optimal_k = optimal_k(0.01);

    println!("bitmap_size: {}", bitmap_size);
    println!("optimal_k: {}", optimal_k);
}

fn bitmap_size(items_count: usize, fp_rate: f64) -> usize {
    let ln2_2 = core::f64::consts::LN_2 * core::f64::consts::LN_2;
    ((-1.0f64 * items_count as f64 * fp_rate.ln()) / ln2_2).ceil() as usize
}

fn optimal_k(fp_rate: f64) -> u32 {
    ((-1.0f64 * fp_rate.ln()) / core::f64::consts::LN_2).ceil() as u32
}
#+END_SRC

We got:

: bitmap_size: 9585059
: optimal_k: 7

This means that a Bloom Filter that represents a set of 1 million items with a false positive rate of 0.01 requires only 9585059 bits (1.14 mb) and 7 hash functions.


#+name: top
#+BEGIN_SRC rust
fn main() {
#+END_SRC

#+name: bottom
#+BEGIN_SRC rust
}
#+END_SRC

#+name: middle
#+BEGIN_SRC rust
println!("Hello, World!");
#+END_SRC


#+BEGIN_SRC rust :tangle example.rs :noweb yes
<<top>>
    <<middle>>
<<bottom>>
#+END_SRC

#+RESULTS:
: Hello, World!



#+name: final-full
#+BEGIN_SRC rust :crates '((bit-vec . "0.6"))
extern crate bit_vec;

use bit_vec::BitVec;
use std::collections::hash_map::{DefaultHasher, RandomState};
use std::hash::{BuildHasher, Hash, Hasher};
use std::marker::PhantomData;

/// A fast standard Bloom Filter implementation that requires only two
/// hash functions, generated by `std::collections::hash_map::DefaultHasher`.
///
/// If an item is not present in the filter then `contains` is guaranteed
/// to return `false` for the queried item.
///
/// The probability that `contains` returns `true` for an item that is not
/// present in the filter is called the False Positive Rate.
///
/// # Example Usage
///
/// ```rust
/// use plum::StandardBloomFilter;
///
/// let items_count = 1_000_000;
/// let fp_rate = 0.01;
///
/// let mut bloom = StandardBloomFilter::new(items_count, fp_rate);
/// bloom.insert("item1");
/// bloom.contains("item1"); /* true */
/// bloom.contains("item2"); /* false */
/// ```
#[doc(inline)]
pub struct StandardBloomFilter<T: ?Sized> {
    bitmap: BitVec,
    /// Size of the bit array.
    optimal_m: usize,
    /// Number of hash functions.
    optimal_k: u32,
    /// Two hash functions from which k number of hashes are derived.
    hashers: [DefaultHasher; 2],
    _marker: PhantomData<T>,
}

impl<T: ?Sized> StandardBloomFilter<T> {
    /// Create a new StandardBloomFilter that expects to store `items_count`
    /// membership with a false positive rate of the value specified in `fp_rate`.
    pub fn new(items_count: usize, fp_rate: f64) -> Self {
        let optimal_m = Self::bitmap_size(items_count, fp_rate);
        let optimal_k = Self::optimal_k(fp_rate);
        let hashers = [
            RandomState::new().build_hasher(),
            RandomState::new().build_hasher(),
        ];
        StandardBloomFilter {
            bitmap: BitVec::from_elem(optimal_m as usize, false),
            optimal_m,
            optimal_k,
            hashers,
            _marker: PhantomData,
        }
    }

    /// Insert item to the set.
    pub fn insert(&mut self, item: &T)
    where
        T: Hash,
    {
        let (h1, h2) = self.hash_kernel(item);

        for k_i in 0..self.optimal_k {
            let index = self.get_index(h1, h2, k_i as u64);

            self.bitmap.set(index, true);
        }
    }

    /// Check if an item is present in the set.
    /// There can be false positives, but no false negatives.
    pub fn contains(&mut self, item: &T) -> bool
    where
        T: Hash,
    {
        let (h1, h2) = self.hash_kernel(item);

        for k_i in 0..self.optimal_k {
            let index = self.get_index(h1, h2, k_i as u64);

            if !self.bitmap.get(index).unwrap() {
                return false;
            }
        }

        true
    }

    /// Get the index from hash value of `k_i`.
    fn get_index(&self, h1: u64, h2: u64, k_i: u64) -> usize {
        h1.wrapping_add((k_i).wrapping_mul(h2)) as usize % self.optimal_m
    }

    /// Calculate the size of `bitmap`.
    /// The size of bitmap depends on the target false positive probability
    /// and the number of items in the set.
    fn bitmap_size(items_count: usize, fp_rate: f64) -> usize {
        let ln2_2 = core::f64::consts::LN_2 * core::f64::consts::LN_2;
        ((-1.0f64 * items_count as f64 * fp_rate.ln()) / ln2_2).ceil() as usize
    }

    /// Calculate the number of hash functions.
    /// The required number of hash functions only depends on the target
    /// false positive probability.
    fn optimal_k(fp_rate: f64) -> u32 {
        ((-1.0f64 * fp_rate.ln()) / core::f64::consts::LN_2).ceil() as u32
    }

    /// Calculate two hash values from which the k hashes are derived.
    fn hash_kernel(&self, item: &T) -> (u64, u64)
    where
        T: Hash,
    {
        let hasher1 = &mut self.hashers[0].clone();
        let hasher2 = &mut self.hashers[1].clone();

        item.hash(hasher1);
        item.hash(hasher2);

        let hash1 = hasher1.finish();
        let hash2 = hasher2.finish();

        (hash1, hash2)
    }
}

fn main() {
    // use plum::StandardBloomFilter;

    let items_count = 1_000_000;
    let fp_rate = 0.01;

    let mut bloom = StandardBloomFilter::new(items_count, fp_rate);
    bloom.insert("item1");
    println!("Does it contain item1? {}", bloom.contains("item1")); /* true */
    println!("Does it contain item2? {}", bloom.contains("item2")); /* false */
}
#+END_SRC

