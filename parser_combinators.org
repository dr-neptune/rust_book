* Learning Parser Combinators with Rust

  All glory to [[https://bodil.lol/parser-combinators/][Bodil's Blog]]

  This teaches the fundamentals of parser combinators.

** Beginner's Mind

There comes a point in the life of every programmer when they find themselves in need of a parser.

The novice programmer will ask, "what is a parser?"

The intermediate programmer will say, "that's easy, I'll write a regular expression."

The master programmer will say, "stand back, I know lex and yacc."

The novice has the right idea.

In the beginner's mind, there are many possibilities. In the expert's mind, there's only the one that the expert got used to.


* The Xcruciating Markup Language

   We're going to write a parser for a simplified version of XML:

#+BEGIN_SRC xml
<parent-element>
  <single-element attribute="value" />
</parent-element>
#+END_SRC

XML elements open with the symbol < and an identifier consisting of a letter followed by any number of letters, numbers, and -. This is followed by some whitespace, and an optional list of attribute pairs: another identifier as defined previously, followed by a = and a double quoted string. Finally there is a closing /> to signify a single element with no children, or a > to signify there is a sequence of child elements following, and finally a closing </, followed by an identifier which must match the opening tag, and a final >.

We are going to parse those elements into a struct that looks like this:

#+name:
#+BEGIN_SRC rust :tangle combinators/src/lib.rs
#[derive(Clone, Debug, PartialEq, Eq)]
struct Element {
    name: String, // string for a name
    attributes: Vec<(String, String)>, // attributes as pairs of strings
    children: Vec<Element>, // a list of child elements that look exactly the same as the parent
}
#+END_SRC

* Defining the Parser

  Parsing is a process of deriving structure from a stream of data. In this a parser is a function that takes in some input, and returns either the parsed output along with the remainder of the input, or an error saying "I couldn't parse this".

  Lets write this down as a function type:

#+name:
#+BEGIN_SRC rust
Fn(Input) -> Result<(Input, Output), Error>

// more concretely, we can fill out the types because we are converting a string into an Element struct.
// since we aren't adding error reporting, we'll just return the bit of the string that we couldn't parse as an error
Fn(&str) -> Result<(&str, Element), &str>
#+END_SRC

* Our First Parser

#+name:
#+BEGIN_SRC rust
// take the first character in a string and decide whether or not its the letter a
// we take a string slice as input, and return a Result of either (&str, ()), or the error type &str.
// with (&str, ()), we are returning a type with the next bit of input to parse and the result.
fn the_letter_a(input: &str) -> Result<(&str, ()), &str> {
    // get the first character of the input. We ask for the iterator chars() over the characters of the string, and we pull the first item
    // this will be an item of type char, wrapped in an Option, so Option<char> where None means we tried to pull a char off an empty string
    match input.chars().next() {
	// if we have a successful parse that matches 'a', return our success value Ok(...)
	// we return 'a'.len_utf8 just to be sure. Its 1, but you never know 
        Some('a') => Ok((&input['a'.len_utf8()..], ())),
	// if we get anything else, or None, return an error
        _ => Err(input),
    }
}

fn main() {
    let yes = "all your string literals are belong to me";
    let no = "this is a string literal";
    let maybe = "";
    println!(
        "Starts with the letter a?:\nyes: {:?}\nno: {:?}\nmaybe: {:?}",
        the_letter_a(yes),
        the_letter_a(no),
        the_letter_a(maybe)
    );
}
#+END_SRC

* A Parser Builder

  We need to find the opening <, as well as >, / and = specifically, so we should write a parser that looks for what we want.
  We will write a fn that produces a parser for a static string of any length, not just a single character. 
  
#+name:
#+BEGIN_SRC rust
// 'static is a reference lifetime that says that the data pointed to by the ref lives for the entire lifetime of the running program
// Instead of returning a result, it takes our expected string as an argument and returns something that looks like a parser
// this is a higher order function.
// instead of doing the work, we return a closure that does the work and that matches our type signature for a parser
fn match_literal(expected: &'static str) -> impl Fn(&str) -> Result<(&str, ()), &str> {
    // move transfers ownership of the item. So in this case, we are transferring ownership of input to the matching Result
    move |input| match input.get(0..expected.len()) {
        // if the input is our expected value, return the Ok
        Some(next) if next == expected => Ok((&input[expected.len()..], ())),
        // if not, return Err
        _ => Err(input),
    }
}

fn main() {
    let match_a = match_literal("a");
    let match_t = match_literal("t");
    let match_n = match_literal("");

    let yes = "all your string literals are belong to me";
    let no = "this is a string literal";
    let maybe = "";

    println!(
        "Starts with the letter a?:\nyes: {:?}\nno: {:?}\nmaybe: {:?}",
        match_a(yes),
        match_t(no),
        match_n(maybe)
    );
}
#+END_SRC

* Testing Our Parser

#+name:
#+BEGIN_SRC rust :tangle combinators/src/main.rs
fn match_literal(expected: &'static str) -> impl Fn(&str) -> Result<(&str, ()), &str> {
    // move transfers ownership of the item. So in this case, we are transferring ownership of input to the matching Result
    move |input| match input.get(0..expected.len()) {
        // if the input is our expected value, return the Ok
        Some(next) if next == expected => Ok((&input[expected.len()..], ())),
        // if not, return Err
        _ => Err(input),
    }
}

#[test]
fn literal_parser() {
    let parse_joe = match_literal("Hello Joe!");

    assert_eq!(Ok(("", ())), parse_joe("Hello Joe!"));
    assert_eq!(
        Ok((" Hello Robert!", ())),
        parse_joe("Hello Joe! Hello Robert!")
    );
    assert_eq!(Err("Hello Mike!"),
	       parse_joe("Hello Mike!"));
}

std::str::pattern

#+END_SRC

In order to run the test above, we tangle to main.rs and run cargo test literal_parser -- --exact

* Exercise

  Can you find a method on the str type in the standard library that would let you write match_literal() without having to do the somewhat cumbersome get indexing?

  Sure, lets try std::str::pattern

#+name:
#+BEGIN_SRC rust
// fn match_literal(expected: &'static str) -> impl Fn(&str) -> Result<(&str, ()), &str> {
//     // move transfers ownership of the item. So in this case, we are transferring ownership of input to the matching Result
//     move |input| match input.get(0..expected.len()) {
//         // if the input is our expected value, return the Ok
//         Some(next) if next == expected => Ok((&input[expected.len()..], ())),
//         // if not, return Err
//         _ => Err(input),
//     }
// }

fn match_literal(expected: &'static str) -> impl Fn(&str) -> Result<(&str, ()), &str> {
    move |input| match input.find(expected) {
        Some(next) => Ok((&input[next + expected.len()..], ())),
        _ => Err(input),
    }
}

fn main() {
    let parse_joe = match_literal("Hello Joe!");
    println!(
        "Test 1:\t{:?}\nTest 2:\t{:?}\nTest 3:\t{:?}",
        parse_joe("Hello Joe!"),
        parse_joe("Hello Joe! Hello Robert!"),
        parse_joe("Hello Mike!")
    );

    let parse_gator_1 = match_literal("<");
    let parse_gator_2 = match_literal(">");
    // let parse_gator_1s = match_literal("</");
    // let parse_gator_2s = match_literal("/>");
    // let parse_eq = match_literal("=");
    let input_str = "<parent-element><single-element attribute='value' /></parent-element>";

    println!(
        "start:\t{:?}\nend:\t\t{:?}\n",
        parse_gator_1(input_str),
        parse_gator_2(input_str)
    );
}
#+END_SRC

* A Parser for Something Less Specific

  Recalling the rule for the element name identifier, it's as follows: one alphabetical character, followed by zero or more of either an alphabetical character, a number, or a dash -

#+name:
#+BEGIN_SRC rust
// this time we are just writing a parser, not a higher order fn that returns a parser
// instead of returning a result type of (), we are returning a String in the tuple along with the remaining input. The String will contain the identifier we've parsed
fn identifier(input: &str) -> Result<(&str, String), &str> {
    let mut matched = String::new();
    let mut chars = input.chars();

    // if there is a letter up front, we push it to matched
    // we've already got a valid identifier if we match the first letter
    match chars.next() {
        Some(next) if next.is_alphabetic() => matched.push(next),
        // if its not an alphabetic, its not an element identifier
        _ => return Err(input),
    }

    // if the first was an alphabetic char, we continue along the string, matching as long as its alphanumeric or a dash
    while let Some(next) = chars.next() {
        if next.is_alphanumeric() || next == '-' {
            matched.push(next);
        } else {
            // we don't return an error if the followup isnt alphanumeric + - since its valid to have in the identifier
            break;
        }
    }

    // the first time we see something that doesn't match the criteria, save our spot and return the String we've built
    let next_index = matched.len();
    Ok((&input[next_index..], matched))
}

fn main() {
    println!(
        "First Test:\t\t{:?}\nSecond Test:\t\t{:?}\nThird Test:\t\t{:?}\n",
        identifier("i-am-an-identifier"),
        identifier("not entirely an idenitifier"),
        identifier("!not at all an identifier")
    );
}
#+END_SRC


: First Test:		Ok(("", "i-am-an-identifier"))
: Second Test:		Ok((" entirely an idenitifier", "not"))
: Third Test:		Err("!not at all an identifier")
: 


Remember that Element struct we're going to parse our XML document into?

#+name:
#+BEGIN_SRC rust
struct Element {
    name: String,
    attributes: Vec<(String, String)>,
    children: Vec<Element>,
}
#+END_SRC

We've just written the code for parsing the name. The String our parser returns goes right in there. It is also the right parser for the first part of every attribute.

* Combinators



