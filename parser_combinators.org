* Learning Parser Combinators with Rust

  All glory to [[https://bodil.lol/parser-combinators/][Bodil's Blog]]

  This teaches the fundamentals of parser combinators.

** Beginner's Mind

There comes a point in the life of every programmer when they find themselves in need of a parser.

The novice programmer will ask, "what is a parser?"

The intermediate programmer will say, "that's easy, I'll write a regular expression."

The master programmer will say, "stand back, I know lex and yacc."

The novice has the right idea.

In the beginner's mind, there are many possibilities. In the expert's mind, there's only the one that the expert got used to.


* The Xcruciating Markup Language

   We're going to write a parser for a simplified version of XML:

#+BEGIN_SRC xml
<parent-element>
  <single-element attribute="value" />
</parent-element>
#+END_SRC

XML elements open with the symbol < and an identifier consisting of a letter followed by any number of letters, numbers, and -. This is followed by some whitespace, and an optional list of attribute pairs: another identifier as defined previously, followed by a = and a double quoted string. Finally there is a closing /> to signify a single element with no children, or a > to signify there is a sequence of child elements following, and finally a closing </, followed by an identifier which must match the opening tag, and a final >.

We are going to parse those elements into a struct that looks like this:

#+name:
#+BEGIN_SRC rust :tangle combinators/src/lib.rs
#[derive(Clone, Debug, PartialEq, Eq)]
struct Element {
    name: String, // string for a name
    attributes: Vec<(String, String)>, // attributes as pairs of strings
    children: Vec<Element>, // a list of child elements that look exactly the same as the parent
}
#+END_SRC

* Building up a lib.rs

This is where I will stick all the working functions as we build this up. This way I can reference them without a ton of copypasting
  
#+name: preamble
#+BEGIN_SRC rust
#[derive(Clone, Debug, PartialEq, Eq)]
struct Element {
    name: String, // string for a name
    attributes: Vec<(String, String)>, // attributes as pairs of strings
    children: Vec<Element>, // a list of child elements that look exactly the same as the parent
}

type ParseResult<'a, Output> = Result<(&'a str, Output), &'a str>;

trait Parser<'a, Output> {
    fn parse(&self, input: &'a str) -> ParseResult<'a, Output>;
}

// implement this trait for any function that matches the signature of a parser
// no we can pass around the same functions we've been passing around so far as parsers fully implementing the Parser trait
impl<'a, F, Output> Parser<'a, Output> for F
where
    F: Fn(&'a str) -> ParseResult<Output>,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, Output> {
        self(input)
    }
}

// rewrite pair with map
fn pair<'a, P1, P2, R1, R2>(parser1: P1, parser2: P2) -> impl Parser<'a, (R1, R2)>
where
    P1: Parser<'a, R1>,
    P2: Parser<'a, R2>,
{
    move |input| {
        // and_then on Result is similar to map but it returns a new Result
        parser1.parse(input).and_then(|(next_input, result1)| {
            parser2
                .parse(next_input)
                .map(|(last_input, result2)| (last_input, (result1, result2)))
        })
    }
}

fn map<'a, P, F, A, B>(parser: P, map_fn: F) -> impl Parser<'a, B>
where
    P: Parser<'a, A>,
    F: Fn(A) -> B,
{
    move |input| {
        parser
            // instead of calling the function directly, we now have something that implements parse
            .parse(input)
            .map(|(next_input, result)| (next_input, map_fn(result)))
    }
}

// use the pair combinator to combine the two parsers into a parser for a tuple of their Results, and then use the map combinator to select the ones we want
fn left<'a, P1, P2, R1, R2>(parser1: P1, parser2: P2) -> impl Parser<'a, R1>
where
    P1: Parser<'a, R1>,
    P2: Parser<'a, R2>,
{
    map(pair(parser1, parser2), |(left, _right)| left)
}

fn right<'a, P1, P2, R1, R2>(Parser1: P1, Parser2: P2) -> impl Parser<'a, R2>
where
    P1: Parser<'a, R1>,
    P2: Parser<'a, R2>,
{
    map(pair(Parser1, Parser2), |(_left, right)| right)
}

// we need to update our two parsers to use Parser and ParseResult
fn match_literal<'a>(expected: &'static str) -> impl Parser<'a, ()> {
    move |input: &'a str| match input.get(0..expected.len()) {
        Some(next) if next == expected => Ok((&input[expected.len()..], ())),
        _ => Err(input),
    }
}

// for identifier, just change the return type and its done
fn identifier(input: &str) -> ParseResult<String> {
    let mut matched = String::new();
    let mut chars = input.chars();

    // if there is a letter up front, we push it to matched
    // we've already got a valid identifier if we match the first letter
    match chars.next() {
        Some(next) if next.is_alphabetic() => matched.push(next),
        // if its not an alphabetic, its not an element identifier
        _ => return Err(input),
    }

    // if the first was an alphabetic char, we continue along the string, matching as long as its alphanumeric or a dash
    while let Some(next) = chars.next() {
        if next.is_alphanumeric() || next == '-' {
            matched.push(next);
        } else {
            // we don't return an error if the followup isnt alphanumeric + - since its valid to have in the identifier
            break;
        }
    }

    // the first time we see something that doesn't match the criteria, save our spot and return the String we've built
    let next_index = matched.len();
    Ok((&input[next_index..], matched))
}

fn one_or_more<'a, P, A>(parser: P) -> impl Parser<'a, Vec<A>>
where
    P: Parser<'a, A>,
{
    move |mut input| {
        let mut result = Vec::new();
        // if the first element is parsed, then add it to the result
        if let Ok((next_input, first_item)) = parser.parse(input) {
            input = next_input;
            result.push(first_item);
        } else {
            return Err(input);
        }
        // then keep parsing until the parser fails
        while let Ok((next_input, next_item)) = parser.parse(input) {
            input = next_input;
            result.push(next_item);
        }

        Ok((input, result))
    }
}

// we can adapt the above to 0 or more
fn zero_or_more<'a, P, A>(parser: P) -> impl Parser<'a, Vec<A>>
where
    P: Parser<'a, A>,
{
    move |mut input| {
        let mut result = Vec::new();

        while let Ok((next_input, next_item)) = parser.parse(input) {
            input = next_input;
            result.push(next_item);
        }

        Ok((input, result))
    }
}

// matches any char, and returns the rest of the string and the parsed string
fn any_char(input: &str) -> ParseResult<char> {
    match input.chars().next() {
        Some(next) => Ok((&input[next.len_utf8()..], next)),
        _ => Err(input),
    }
}

// invoke the parser, then call our pred fn on the value if the parser succeeded.
fn pred<'a, P, A, F>(parser: P, predicate: F) -> impl Parser<'a, A>
where
    P: Parser<'a, A>,
    F: Fn(&A) -> bool,
{
    move |input| {
        if let Ok((next_input, value)) = parser.parse(input) {
            if predicate(&value) {
                return Ok((next_input, value));
            }
        }
        Err(input)
    }
}

// whitespace_char parser
fn whitespace_char<'a>() -> impl Parser<'a, char> {
    pred(any_char, |c| c.is_whitespace())
}

// implement one or more and zero or more whitespace
fn space1<'a>() -> impl Parser<'a, Vec<char>> {
    one_or_more(whitespace_char())
}

fn space0<'a>() -> impl Parser<'a, Vec<char>> {
    zero_or_more(whitespace_char())
}

// parses quoted strings
fn quoted_string<'a>() -> impl Parser<'a, String> {
    // used for type coercion
    map(
	right(
	    // opening quote
	    match_literal("\""),
	    // the quoted string
	    left(
		// get characters
		// matches anything but another quote
		zero_or_more(pred(any_char, |c| *c != '"')), 
		// up to matching the ending bracket
		match_literal("\""),
	    ),
	),
	// convert our returned Vec into a String by coercion to iter and collect
	|chars| chars.into_iter().collect(),
    )
}

fn attribute_pair<'a>() -> impl Parser<'a, (String, String)> {
    // pair is a combinator for parsing a tuple of values
    // identifier gets attribute name
    // right returns the right element of the tuple
    // the match literal finds the =, then drops it
    // the quoted string pulls the value of the argument
    pair(identifier, right(match_literal("="), quoted_string()))
}

// build the vector
fn attributes<'a>() -> impl Parser<'a, Vec<(String, String)>> {
    // zero or more occurrences of whitespace, then an attribute pair.
    // use right to discard the whitespace, keep the pair
    zero_or_more(right(space1(), attribute_pair()))
}

#+END_SRC

* Defining the Parser

  Parsing is a process of deriving structure from a stream of data. In this a parser is a function that takes in some input, and returns either the parsed output along with the remainder of the input, or an error saying "I couldn't parse this".

  Lets write this down as a function type:

#+name:
#+BEGIN_SRC rust
Fn(Input) -> Result<(Input, Output), Error>

// more concretely, we can fill out the types because we are converting a string into an Element struct.
// since we aren't adding error reporting, we'll just return the bit of the string that we couldn't parse as an error
Fn(&str) -> Result<(&str, Element), &str>
#+END_SRC

* Our First Parser

#+name:
#+BEGIN_SRC rust
// take the first character in a string and decide whether or not its the letter a
// we take a string slice as input, and return a Result of either (&str, ()), or the error type &str.
// with (&str, ()), we are returning a type with the next bit of input to parse and the result.
fn the_letter_a(input: &str) -> Result<(&str, ()), &str> {
    // get the first character of the input. We ask for the iterator chars() over the characters of the string, and we pull the first item
    // this will be an item of type char, wrapped in an Option, so Option<char> where None means we tried to pull a char off an empty string
    match input.chars().next() {
        // if we have a successful parse that matches 'a', return our success value Ok(...)
        // we return 'a'.len_utf8 just to be sure. Its 1, but you never know
        Some('a') => Ok((&input['a'.len_utf8()..], ())),
        // if we get anything else, or None, return an error
        _ => Err(input),
    }
}

fn main() {
    let yes = "all your string literals are belong to me";
    let no = "this is a string literal";
    let maybe = "";
    println!(
        "Starts with the letter a?:\nyes: {:?}\nno: {:?}\nmaybe: {:?}",
        the_letter_a(yes),
        the_letter_a(no),
        the_letter_a(maybe)
    );
}
#+END_SRC

: Starts with the letter a?:
: yes: Ok(("ll your string literals are belong to me", ()))
: no: Err("this is a string literal")
: maybe: Err("")

* A Parser Builder

  We need to find the opening <, as well as >, / and = specifically, so we should write a parser that looks for what we want.
  We will write a fn that produces a parser for a static string of any length, not just a single character. 
  
#+name:
#+BEGIN_SRC rust
// 'static is a reference lifetime that says that the data pointed to by the ref lives for the entire lifetime of the running program
// Instead of returning a result, it takes our expected string as an argument and returns something that looks like a parser
// this is a higher order function.
// instead of doing the work, we return a closure that does the work and that matches our type signature for a parser
fn match_literal(expected: &'static str) -> impl Fn(&str) -> Result<(&str, ()), &str> {
    // move transfers ownership of the item. So in this case, we are transferring ownership of input to the matching Result
    move |input| match input.get(0..expected.len()) {
        // if the input is our expected value, return the Ok
        Some(next) if next == expected => Ok((&input[expected.len()..], ())),
        // if not, return Err
        _ => Err(input),
    }
}

fn main() {
    let match_a = match_literal("a");
    let match_t = match_literal("t");
    let match_n = match_literal("");

    let yes = "all your string literals are belong to me";
    let no = "this is a string literal";
    let maybe = "";

    println!(
        "Starts with the letter a?:\nyes: {:?}\nno: {:?}\nmaybe: {:?}",
        match_a(yes),
        match_t(no),
        match_n(maybe)
    );
}
#+END_SRC

: Starts with the letter a?:
: yes: Ok(("ll your string literals are belong to me", ()))
: no: Ok(("his is a string literal", ()))
: maybe: Ok(("", ()))

* Testing Our Parser

#+name:
#+BEGIN_SRC rust :tangle combinators/src/main.rs
fn match_literal(expected: &'static str) -> impl Fn(&str) -> Result<(&str, ()), &str> {
    // move transfers ownership of the item. So in this case, we are transferring ownership of input to the matching Result
    move |input| match input.get(0..expected.len()) {
        // if the input is our expected value, return the Ok
        Some(next) if next == expected => Ok((&input[expected.len()..], ())),
        // if not, return Err
        _ => Err(input),
    }
}

#[test]
fn literal_parser() {
    let parse_joe = match_literal("Hello Joe!");

    assert_eq!(Ok(("", ())), parse_joe("Hello Joe!"));
    assert_eq!(
        Ok((" Hello Robert!", ())),
        parse_joe("Hello Joe! Hello Robert!")
    );
    assert_eq!(Err("Hello Mike!"),
	       parse_joe("Hello Mike!"));
}
#+END_SRC

In order to run the test above, we tangle to main.rs and run cargo test literal_parser -- --exact

* Exercise

  Can you find a method on the str type in the standard library that would let you write match_literal() without having to do the somewhat cumbersome get indexing?

  Sure, lets try std::str::pattern

#+name:
#+BEGIN_SRC rust
// fn match_literal(expected: &'static str) -> impl Fn(&str) -> Result<(&str, ()), &str> {
//     // move transfers ownership of the item. So in this case, we are transferring ownership of input to the matching Result
//     move |input| match input.get(0..expected.len()) {
//         // if the input is our expected value, return the Ok
//         Some(next) if next == expected => Ok((&input[expected.len()..], ())),
//         // if not, return Err
//         _ => Err(input),
//     }
// }

fn match_literal(expected: &'static str) -> impl Fn(&str) -> Result<(&str, ()), &str> {
    move |input| match input.find(expected) {
        Some(next) => Ok((&input[next + expected.len()..], ())),
        _ => Err(input),
    }
}

fn main() {
    let parse_joe = match_literal("Hello Joe!");
    println!(
        "Test 1:\t{:?}\nTest 2:\t{:?}\nTest 3:\t{:?}",
        parse_joe("Hello Joe!"),
        parse_joe("Hello Joe! Hello Robert!"),
        parse_joe("Hello Mike!")
    );

    let parse_gator_1 = match_literal("<");
    let parse_gator_2 = match_literal(">");
    // let parse_gator_1s = match_literal("</");
    // let parse_gator_2s = match_literal("/>");
    // let parse_eq = match_literal("=");
    let input_str = "<parent-element><single-element attribute='value' /></parent-element>";

    println!(
        "start:\t{:?}\nend:\t\t{:?}\n",
        parse_gator_1(input_str),
        parse_gator_2(input_str)
    );
}
#+END_SRC

: Test 1:	Ok(("", ()))
: Test 2:	Ok((" Hello Robert!", ()))
: Test 3:	Err("Hello Mike!")
: start:	Ok(("parent-element><single-element attribute=\'value\' /></parent-element>", ()))
: end:		Ok(("<single-element attribute=\'value\' /></parent-element>", ()))
: 

* A Parser for Something Less Specific

  Recalling the rule for the element name identifier, it's as follows: one alphabetical character, followed by zero or more of either an alphabetical character, a number, or a dash -

#+name:
#+BEGIN_SRC rust
// this time we are just writing a parser, not a higher order fn that returns a parser
// instead of returning a result type of (), we are returning a String in the tuple along with the remaining input. The String will contain the identifier we've parsed
fn identifier(input: &str) -> Result<(&str, String), &str> {
    let mut matched = String::new();
    let mut chars = input.chars();

    // if there is a letter up front, we push it to matched
    // we've already got a valid identifier if we match the first letter
    match chars.next() {
        Some(next) if next.is_alphabetic() => matched.push(next),
        // if its not an alphabetic, its not an element identifier
        _ => return Err(input),
    }

    // if the first was an alphabetic char, we continue along the string, matching as long as its alphanumeric or a dash
    while let Some(next) = chars.next() {
        if next.is_alphanumeric() || next == '-' {
            matched.push(next);
        } else {
            // we don't return an error if the followup isnt alphanumeric + - since its valid to have in the identifier
            break;
        }
    }

    // the first time we see something that doesn't match the criteria, save our spot and return the String we've built
    let next_index = matched.len();
    Ok((&input[next_index..], matched))
}

fn main() {
    println!(
        "First Test:\t\t{:?}\nSecond Test:\t\t{:?}\nThird Test:\t\t{:?}\n",
        identifier("i-am-an-identifier"),
        identifier("not entirely an idenitifier"),
        identifier("!not at all an identifier")
    );
}
#+END_SRC

: First Test:		Ok(("", "i-am-an-identifier"))
: Second Test:		Ok((" entirely an idenitifier", "not"))
: Third Test:		Err("!not at all an identifier")
: 


Remember that Element struct we're going to parse our XML document into?

#+name:
#+BEGIN_SRC rust
struct Element {
    name: String,
    attributes: Vec<(String, String)>,
    children: Vec<Element>,
}
#+END_SRC

We've just written the code for parsing the name. The String our parser returns goes right in there. It is also the right parser for the first part of every attribute.

* Combinators

  We can now parse <, and the following identifier, but we need to parse both, in order, to be able to make progress. The next step is to write another parser builder function, but one that takes two parsers as inputs and returns a new parser which parses both of them in order. In other words, a parser /combinator/, which /combines/ two parsers into a new one

#+name:
#+BEGIN_SRC rust
// takes two parsers as input, and returns a new parser which parses both of them in order
// Parser 1, Parser 2, Result 1, Result 2. P1, P2 are functions
// our final result is a parser that returns (R1, R2)
// runs P1 on input, keeps the result, then runs P2 on what P1 returned, and if they both worked, return the tuple (R1, R2)
// Fn Type Signature
// Accepts two parsers
fn pair<P1, P2, R1, R2>(parser1: P1, parser2: P2) -> impl Fn(&str) -> Result<(&str, (R1, R2)), &str>
where
    // they both return parsers
    P1: Fn(&str) -> Result<(&str, R1), &str>,
    P2: Fn(&str) -> Result<(&str, R2), &str>,
{
    // run P1 on the input
    move |input| match parser1(input) {
        // if P1 succeeds, take its return val and run P2 on it
        Ok((next_input, result1)) => match parser2(next_input) {
            // if P2 succeeds, return the final input and (R1, R2)
            Ok((final_input, result2)) => Ok((final_input, (result1, result2))),
            Err(err) => Err(err),
        },
        Err(err) => Err(err),
    }
}

fn identifier(input: &str) -> Result<(&str, String), &str> {
    let mut matched = String::new();
    let mut chars = input.chars();

    // if there is a letter up front, we push it to matched
    // we've already got a valid identifier if we match the first letter
    match chars.next() {
        Some(next) if next.is_alphabetic() => matched.push(next),
        // if its not an alphabetic, its not an element identifier
        _ => return Err(input),
    }

    // if the first was an alphabetic char, we continue along the string, matching as long as its alphanumeric or a dash
    while let Some(next) = chars.next() {
        if next.is_alphanumeric() || next == '-' {
            matched.push(next);
        } else {
            // we don't return an error if the followup isnt alphanumeric + - since its valid to have in the identifier
            break;
        }
    }

    // the first time we see something that doesn't match the criteria, save our spot and return the String we've built
    let next_index = matched.len();
    Ok((&input[next_index..], matched))
}

fn match_literal(expected: &'static str) -> impl Fn(&str) -> Result<(&str, ()), &str> {
    move |input| match input.find(expected) {
        Some(next) => Ok((&input[next + expected.len()..], ())),
        _ => Err(input),
    }
}

fn main() {
    let tag_opener = pair(match_literal("<"), identifier);
    println!(
        "First Element:\t{:?}\nNot Quite:\t{:?}\nNope:\t{:?}\n",
        tag_opener("<my-first-element/>"),
        tag_opener("oops"),
        tag_opener("<!too spicy")
    );
}
#+END_SRC

: First Element:	Ok(("/>", ((), "my-first-element")))
: Not Quite:	Err("oops")
: Nope:	Err("!too spicy")

It works! But we return a result type ((), String), when we really only care about the String.

Som eof our parsers only match patterns in the input without producing values, and so their outputs can be safely ignored. To accomodate this pattern, we're going to use our pair combinator to write two other combinators:
- left, which discards the result of the first parser and returns the second
- right, which discards the () on the LHS of the pair and keeps only our String

* Enter the Functor

  Before we go on, let's talk about another combinator: map

  This combinator has one purpose: to change the type of the result. For instance, if we have a parser that returns ((), String), and we want to return just that String. To do this, we pass it a function that knows how to convert from the original type to the new one. |(_left, right)| right. More generalized, it would look like Fn(A) -> B where A is the original result type of the parser and B is the new one.

#+name:
#+BEGIN_SRC rust
// P is our parser. It returns A on success. F is the function we're going to use to map P into our return value, which looks the same as P except its result type is B rather than A
fn map1<P, F, A, B>(parser: P, map_fn: F) -> impl Fn(&str) -> Result<(&str, B), &str>
where
    P: Fn(&str) -> Result<(&str, A), &str>,
    F: Fn(A) -> B,
{
    // run parser(input)
    move |input| match parser(input) {
        // if success, take the result and apply the map fn to it and return that
        Ok((next_input, result)) => Ok((next_input, map_fn(result))),
        Err(err) => Err(err),
    }
}

// map is a common function that Result actually implements
fn map<P, F, A, B>(parser: P, map_fn: F) -> impl Fn(&str) -> Result<(&str, B), &str>
where
    P: Fn(&str) -> Result<(&str, A), &str>,
    F: Fn(A) -> B,
{
    move |input|
    parser(input)
	.map(|(next_input, result)| (next_input, map_fn(result)))
}

fn main() {}
#+END_SRC

In this case, this is called a functor. If we have a thing with type A in it, and we have a map function available that you can pass a function from A to B into to turn it into the same kind of thing but with type B in it instead, that is a functor. This is common in rust, such as in Option, Result, Iterator, and even Future. This is not explicitly named as such, since we can't express a functor as a generalized thing in Rust's type system (because it lacks higher kinded types).

* Time For A Trait

  From TRPL:

  A Trait tells teh Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic can be any type that has certain behavior.

  Back to it: We keep repeating the shape of the parser type signature: Fn(&str) -> Result<(&str, Output), &str>. Instead of writing it out over and over, we can introduce a trait to make things more readable and add to add some extensibility to our parsers.

#+name:
#+BEGIN_SRC rust
// make a type alias for that return type we keep using
// now instead of typing this out all the time, we can just type ParseResult<String> or similar
// the lifetime is because the type declaration requires it, but a lot of the time the Rust compiler should be able to infer it for you
// the lifetime 'a specifically refers to the lifetime of the input
type ParseResult<'a, Output> = Result<(&'a str, Output), &'a str>;

trait Parser<'a, Output> {
    fn parse(&self, input: &'a str) -> ParseResult<'a, Output>;
}

// implement this trait for any function that matches the signature of a parser
// no we can pass around the same functions we've been passing around so far as parsers fully implementing the Parser trait
impl<'a, F, Output> Parser<'a, Output> for F
where
    F: Fn(&'a str) -> ParseResult<Output>,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, Output> {
        self(input)
    }
}

// rewrite map
fn map<'a, P, F, A, B>(parser: P, map_fn: F) -> impl Parser<'a, B>
where
    P: Parser<'a, A>,
    F: Fn(A) -> B,
{
    move |input| {
        parser
            // instead of calling the function directly, we now have something that implements parse
            .parse(input)
            .map(|(next_input, result)| (next_input, map_fn(result)))
    }
}

// rewrite the pair function
fn pair1<'a, P1, P2, R1, R2>(parser1: P1, parser2: P2) -> impl Parser<'a, (R1, R2)>
where
    P1: Parser<'a, R1>,
    P2: Parser<'a, R2>,
{
    // if parser matches input
    move |input| match parser1.parse(input) {
        // match the next input with parser2
        Ok((next_input, result1)) => match parser2.parse(next_input) {
            // if that works, then massage it into a form we want
            Ok((final_input, result2)) => Ok((final_input, (result1, result2))),
            Err(err) => Err(err),
        },
        Err(err) => Err(err),
    }
}

// rewrite pair with map
fn pair<'a, P1, P2, R1, R2>(parser1: P1, parser2: P2) -> impl Parser<'a, (R1, R2)>
where
    P1: Parser<'a, R1>,
    P2: Parser<'a, R2>,
{
    move |input| {
	// and_then on Result is similar to map but it returns a new Result 
        parser1.parse(input).and_then(|(next_input, result1)| {
            parser2
                .parse(next_input)
                .map(|(last_input, result2)| (last_input, (result1, result2)))
        })
    }
}

fn main() {}
#+END_SRC

* Left and Right

#+name:
#+BEGIN_SRC rust
type ParseResult<'a, Output> = Result<(&'a str, Output), &'a str>;

trait Parser<'a, Output> {
    fn parse(&self, input: &'a str) -> ParseResult<'a, Output>;
}

// implement this trait for any function that matches the signature of a parser
// no we can pass around the same functions we've been passing around so far as parsers fully implementing the Parser trait
impl<'a, F, Output> Parser<'a, Output> for F
where
    F: Fn(&'a str) -> ParseResult<Output>,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, Output> {
        self(input)
    }
}

// rewrite pair with map
fn pair<'a, P1, P2, R1, R2>(parser1: P1, parser2: P2) -> impl Parser<'a, (R1, R2)>
where
    P1: Parser<'a, R1>,
    P2: Parser<'a, R2>,
{
    move |input| {
        // and_then on Result is similar to map but it returns a new Result
        parser1.parse(input).and_then(|(next_input, result1)| {
            parser2
                .parse(next_input)
                .map(|(last_input, result2)| (last_input, (result1, result2)))
        })
    }
}

fn map<'a, P, F, A, B>(parser: P, map_fn: F) -> impl Parser<'a, B>
where
    P: Parser<'a, A>,
    F: Fn(A) -> B,
{
    move |input| {
        parser
            // instead of calling the function directly, we now have something that implements parse
            .parse(input)
            .map(|(next_input, result)| (next_input, map_fn(result)))
    }
}

// use the pair combinator to combine the two parsers into a parser for a tuple of their Results, and then use the map combinator to select the ones we want
fn left<'a, P1, P2, R1, R2>(parser1: P1, parser2: P2) -> impl Parser<'a, R1>
where
    P1: Parser<'a, R1>,
    P2: Parser<'a, R2>,
{
    map(pair(parser1, parser2), |(left, _right)| left)
}

fn right<'a, P1, P2, R1, R2>(Parser1: P1, Parser2: P2) -> impl Parser<'a, R2>
where
    P1: Parser<'a, R1>,
    P2: Parser<'a, R2>,
{
    map(pair(Parser1, Parser2), |(_left, right)| right)
}

// we need to update our two parsers to use Parser and ParseResult
fn match_literal<'a>(expected: &'static str) -> impl Parser<'a, ()> {
    move |input: &'a str| match input.get(0..expected.len()) {
        Some(next) if next == expected => Ok((&input[expected.len()..], ())),
        _ => Err(input),
    }
}

// for identifier, just change the return type and its done
fn identifier(input: &str) -> ParseResult<String> {
    let mut matched = String::new();
    let mut chars = input.chars();

    // if there is a letter up front, we push it to matched
    // we've already got a valid identifier if we match the first letter
    match chars.next() {
        Some(next) if next.is_alphabetic() => matched.push(next),
        // if its not an alphabetic, its not an element identifier
        _ => return Err(input),
    }

    // if the first was an alphabetic char, we continue along the string, matching as long as its alphanumeric or a dash
    while let Some(next) = chars.next() {
        if next.is_alphanumeric() || next == '-' {
            matched.push(next);
        } else {
            // we don't return an error if the followup isnt alphanumeric + - since its valid to have in the identifier
            break;
        }
    }

    // the first time we see something that doesn't match the criteria, save our spot and return the String we've built
    let next_index = matched.len();
    Ok((&input[next_index..], matched))
}

fn main() {
    let tag_opener = right(match_literal("<"), identifier);

    println!(
        "First Test:\t{:?}\nSecond Test:\t{:?}\nThird Test:\t{:?}",
        tag_opener.parse("<my-first-element/>"),
        tag_opener.parse("oops"),
        tag_opener.parse("<!oops")
    );
}
#+END_SRC

First Test:	Ok(("/>", "my-first-element"))
Second Test:	Err("oops")
Third Test:	Err("!oops")

* One Or More

  We have an opening <, and we've got an identifier. Next should be out first attribute pair.

  But first we need to deal with whitespace, either a single instance of, or multiple in a row.

  We should write a combinator that expresses the idea of one or more parsers.

#+name:
#+BEGIN_SRC rust
type ParseResult<'a, Output> = Result<(&'a str, Output), &'a str>;

trait Parser<'a, Output> {
    fn parse(&self, input: &'a str) -> ParseResult<'a, Output>;
}

// implement this trait for any function that matches the signature of a parser
// no we can pass around the same functions we've been passing around so far as parsers fully implementing the Parser trait
impl<'a, F, Output> Parser<'a, Output> for F
where
    F: Fn(&'a str) -> ParseResult<Output>,
{
    fn parse(&self, input: &'a str) -> ParseResult<'a, Output> {
        self(input)
    }
}

// return type of the parser is A, and the return type from the combinator parser is Vec<A> -- any number of As
fn one_or_more<'a, P, A>(parser: P) -> impl Parser<'a, Vec<A>>
where
    P: Parser<'a, A>,
{
    move |mut input| {
        let mut result = Vec::new();
        // if the first element is parsed, then add it to the result
        if let Ok((next_input, first_item)) = parser.parse(input) {
            input = next_input;
            result.push(first_item);
        } else {
            return Err(input);
        }
        // then keep parsing until the parser fails
        while let Ok((next_input, next_item)) = parser.parse(input) {
            input = next_input;
            result.push(next_item);
        }

        Ok((input, result))
    }
}

// we can adapt the above to 0 or more
fn zero_or_more<'a, P, A>(parser: P) -> impl Parser<'a, Vec<A>>
where
    P: Parser<'a, A>,
{
    move |mut input| {
        let mut result = Vec::new();

        while let Ok((next_input, next_item)) = parser.parse(input) {
            input = next_input;
            result.push(next_item);
        }

        Ok((input, result))
    }
}

// we need to update our two parsers to use Parser and ParseResult
fn match_literal<'a>(expected: &'static str) -> impl Parser<'a, ()> {
    move |input: &'a str| match input.get(0..expected.len()) {
        Some(next) if next == expected => Ok((&input[expected.len()..], ())),
        _ => Err(input),
    }
}

fn main() {
    // one or more
    let parser1 = one_or_more(match_literal("ha"));
    let parser0 = zero_or_more(match_literal("ha"));

    println!("P1 Test 1:\t{:?}\nP1 Test 2:\t{:?}\nP1 Test 3:\t{:?}\nP0 Test 1:\t{:?}\nP0 Test 2:\t{:?}\nP0 Test 3:\t{:?}",
	     parser1.parse("hahaha"),
	     parser1.parse("ahah"),
	     parser1.parse(""),
	     parser0.parse("hahaha"),
	     parser0.parse("ahah"),
	     parser0.parse(""));
}
#+END_SRC

: P1 Test 1:	Ok(("", [(), (), ()]))
: P1 Test 2:	Err("ahah")
: P1 Test 3:	Err("")
: P0 Test 1:	Ok(("", [(), (), ()]))
: P0 Test 2:	Ok(("ahah", []))
: P0 Test 3:	Ok(("", []))

At this point, its tempting to express one_or_more in terms of zero_or_more with something like this:

#+name:
#+BEGIN_SRC rust
fn one_or_more<'a, P, A>(parser: P) -> impl Parser<'a, Vec<A>>
where
    P: Parser<'a, A>,
{
    map(pair(parser, zero_or_more(parser)), |(head, mut tail)| {
	tail.insert(0, head);
	tail
    })
}
#+END_SRC

Unfortunately, we run into Rust problems here. We own the parser, so we can't go around passing it as an argument twice. The compiler will tell us that we're trying to move an already moved value.
We also run into issues if we pass references instead, as it gives us another set of borrow checker troubles. Also, since they are functions, they don't do anything like implement Clone.

So we are stuck with the constraint that we can't repeat our parsers easily in combinators.

This just means we can't express one_or_more using combinators. This is not a big deal, since we really just need these two anyway.
If we wanted to get fancy, we could write a combinator that takes a RangeBound in addition to a parser and repeats it according to a range.

* A Predicate Combinator

  If there are no attributes, then whitespace is optional, and we could encounter an immediate > or />. But, if there is an attribute, there must be whitespace first. Luckily for us, there must also be a whitespace between each attribute, if there are several, so we have a sequence of zero or more occurrences of one or more whitespace items followed by the attribute.

  We could use match_literal with a string containing a single space, or we could write out a parser which consumes any number of whitespace characters using the is_whitespace predicate like we did with identifier.
  Instead, we are going to write a parser any_char which returns a single char as long as there is one left in the input, and a combinator pred which takes a parser and a predicate function, and combine the two like this:
  pred(any_char, |c| c.is_whitespace()).

#+name:
#+BEGIN_SRC rust :noweb yes
<<preamble>>

fn main() {
    // test pred and any_char
    let parser = pred(any_char, |c| *c == 'o');
    println!(
        "First Test:\t{:?}\nSecond Test:\t{:?}",
        parser.parse("omg"),
        parser.parse("lol")
    );
    
}
#+END_SRC

: First Test:	Ok(("mg", 'o'))
: Second Test:	Err("lol")


* Quoted Strings

  Now we can parse some attributes.

  We have all the individual attributes.
  We have identifier for the attribute name
  The = is just match_literal("=")
  We're short one quoted string parser

#+name:
#+BEGIN_SRC rust :noweb yes
<<preamble>>

// parses quoted strings
fn quoted_string<'a>() -> impl Parser<'a, String> {
    // used for type coercion
    map(
	right(
	    // opening quote
	    match_literal("\""),
	    // the quoted string
	    left(
		// get characters
		// matches anything but another quote
		zero_or_more(pred(any_char, |c| *c != '"')), 
		// up to matching the ending bracket
		match_literal("\""),
	    ),
	),
	// convert our returned Vec into a String by coercion to iter and collect
	|chars| chars.into_iter().collect(),
    )
}

// test
fn main() {
    println!("First Test:\t{:?}\nSecond Test:\t{:?}",
	     quoted_string().parse("\"Hello Joe!\""),
    quoted_string().parse("\"Hasta La Pasta, Amigo\""));
}
#+END_SRC

: First Test:	Ok(("", "Hello Joe!"))
: Second Test:	Ok(("", "Hasta La Pasta, Amigo"))

* At Last, Parsing Attributes

  We can now parse whitespace, identifiers, = signs, and quoted strings. That is all we need for parsing attributes.

  First lets write a parser for an attribute pair. We're going to be storing them as a Vec<(String, String)>, so we need a parser for that (String, String) to feed to our trust zero_or_more combinator.

#+name:
#+BEGIN_SRC rust :noweb yes
<<preamble>>

fn attribute_pair<'a>() -> impl Parser<'a, (String, String)> {
    // pair is a combinator for parsing a tuple of values
    // identifier gets attribute name
    // right returns the right element of the tuple
    // the match literal finds the =, then drops it
    // the quoted string pulls the value of the argument
    pair(identifier, right(match_literal("="), quoted_string()))
}

// build the vector
fn attributes<'a>() -> impl Parser<'a, Vec<(String, String)>> {
    // zero or more occurrences of whitespace, then an attribute pair.
    // use right to discard the whitespace, keep the pair
    zero_or_more(right(space1(), attribute_pair()))
}

// test
fn main() {
    println!("First Test:\t{:?}",
    attributes().parse(" one=\"1\" two=\"2\""))
}
#+END_SRC

: First Test:	Ok(("", [("one", "1"), ("two", "2")]))

* So Close Now

We just have 2 versions of the element tag to deal with: the single element, and the parent element with children

Let's see if we can write a parser for everything the two have in common: The opening <, the element name, and the attributes.
Let's see if we can get a result type of (String, Vec<(String, String)>) out of a couple of combinators

#+name:
#+BEGIN_SRC rust :noweb yes
<<preamble>>

fn element_start<'a>() -> impl Parser<'a, (String, Vec<(String, String)>)> {
    right(match_literal("<"),
	  pair(identifier, attributes()))
}

// parser for a single element
fn single_element<'a>() -> impl Parser<'a, Element> {
    map(
	left(element_start(), match_literal("/>")),
	// construct ze element
	|(name, attributes)| Element {
	    name,
	    attributes,
	    children: vec![],
	}
    )
}

fn main() {
    println!("First Test:\t{:#?}",
    single_element().parse("<div class=\"float\" style=\"butterfly\"/>"));
}
#+END_SRC

: First Test:	Ok(("", Element { name: "div", attributes: [("class", "float")], children: [] }))

: First Test:	Ok(
:     (
:         "",
:         Element {
:             name: "div",
:             attributes: [
:                 (
:                     "class",
:                     "float",
:                 ),
:                 (
:                     "style",
:                     "butterfly",
:                 ),
:             ],
:             children: [],
:         },
:     ),
: )

It parses! and it looks nice.
Unfortunately, it is slow. And in Rust, we don't do slow.

* To Infinity and Beyond


