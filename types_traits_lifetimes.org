* Generic Types, Traits, and Lifetimes

  In Rust, we use generics as a tool for effectively handling the duplication of concepts. Generics are abstract stand-ins for concrete types or other properties.
  When writing code, we can express the behavior of generics or how they relate to other generics without knowing what will be in their place when compiling and running the code.

  First we'll review how to extract a function to reduce code duplication. Next, we'll use the same technique to make a generic function from two functions that differ only in the types of their parameters.

  Then we'll use traits to define behavior in a generic way. We can combine traits with generic types to constrain a generic type to only those types that have a particular behavior.

  Then we'll discuss lifetimes, a variety of generics that give the compiler information about how references relate to each other.
  
** Removing Duplication by Extracting a Function

   Consider the following program:
   
#+name:
#+BEGIN_SRC rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
#+END_SRC

If we wish to do this over multiple lists, we should write a function

#+name:
#+BEGIN_SRC rust
fn largest(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {}", result);
}
#+END_SRC

We've abstracted the process into a function. We:

1. Identified duplicate code
2. Extracted the duplicate code into the boyd of the function and specified the inputs and return values of that code in the function signature
3. Updated the two instances of duplicated code to call the function instead

Next we'll use the same steps with generics to reduce code duplication in different ways. In the same way that the function body can operator on an abstract list instead of specific values, generics allow code to operate on abstract types.

* Generic Data Types

  We use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types.

** In Function Definitions

   When defining a fn that uses generics, we place the generics in the signature of the function where we would usually specify the data types of the parameters and return value.

#+name:
#+BEGIN_SRC rust
fn largest_i32(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &[char]) -> &char {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let char_list = vec!['y', 'm', 'a', 'q'];

    println!("The largest number is {}", largest_i32(&number_list));
    println!("The largest char is {}", largest_char(&char_list));
}
#+END_SRC

The function bodies have the same code, so let's eliminate the duplication by introducing a generic type parameter in a single function.

To parameterize the types in the new function we need to name the type parameter, just as we do for the value parameters to a function. We can use any identifier as a type parameter name.

Similar to declaring a parameter in the body of a function in the function signature, we have to declare the type parameter name in the signature so the compiler knows what that name means.

We use a signature like:

#+name:
#+BEGIN_SRC rust
fn largest<T>(list: &[T]) -> &T {
#+END_SRC

which can be read as: the function largest is generic over some type T. This function has a parameter named list, which is a slice of values of type T. The largest function will return a reference to a value of the same type T.

#+name:
#+BEGIN_SRC rust
fn largest<T>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
	if item > largest {
	    largest = item;
	}
    }
    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let char_list = vec!['y', 'm', 'a', 'q'];

    println!("The largest number is {}", largest_i32(&number_list));
    println!("The largest char is {}", largest_char(&char_list));
}
#+END_SRC

If we run that, we get an error. It mentions std::cmp::PartialOrd which is a trait. This error is saying that the body of largest won't work for all possible types that T could be.
Because we want to compare values of type T in the boyd, we can only use types whose values can be ordered. 

** In Struct Definitions

   We can also define structs to use a generic type parameter in one or more fields using the <> syntax.

#+BEGIN_SRC rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };

    println!("x: {:?} y: {:?}", float.x, float.y);
}
#+END_SRC

Note that because we've used only one generic type to define Point<T>, this definition says that the Point<T> struct is generic over some type T, and the fields x and y are both the same type.

To define a Point struct where x and y are both generics but could have different types, we can use multiple generic type parameters.

#+name:
#+BEGIN_SRC rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
#+END_SRC

** In Enum Definitions

   Let's look again at the Option enum:
   
#+name:
#+BEGIN_SRC rust
enum Option<T> {
    Some(T),
    None,
}
#+END_SRC

enums can use multiple generic types as well

#+name:
#+BEGIN_SRC rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+END_SRC

When you recognize situations in your code with multiple struct or enum definitions that differ only in the types of values they hold, you can avoid duplication by using generic types instead.

** In Method Definitions

   We can implement methods on structs and enums and use generic types in their definitions too

#+name:
#+BEGIN_SRC rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };
    let q = Point { x: 5.0, y: 10.0 };
    println!(
        "p.x = {}\nd(Origin) = {}\nq.x = {}",
        p.x(),
        q.distance_from_origin(),
        q.x()
    );
}
#+END_SRC

Note that we have to declare T just after impl so we can use it to specify that we're implementing methods on the type Point<T>.

Generic type parameters in a struct definition aren't always the same as those you use in that struct's method signatures.

#+name:
#+BEGIN_SRC rust
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };
    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
#+END_SRC

The purpose of this example is to demonstrate a situation in which some generic parameters are declared with impl and some are declared with the method definition. 

** Performance of Code Using Generics

   Rust implements generics in such a way that your code doesn't run any slower using generic types than it would with concrete types.
   It accomplishes this by performing monomorphization of the code that is using generics at compile time. Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used when compiled.
 
* Traits: Defining Shared Behavior

  A trait tells the Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way.
  We can use trait bounds to specify that a generic can be any type that has a certain behavior.

** Defining a Trait

   A type's behavior consists of the methods that we can call on that type. Different types share the same behavior if we can call the same methods on all those types. Trait definitions are a
   way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.

   Suppose we want to make a media aggregator library that can display summaries of data that might be stored in a NewsArticle or Tweet instance.

   To do this, we need a summary from each type, and we need to request that summary by calling a summarize method on an instance.
   
#+name:
#+BEGIN_SRC rust
pub trait Summary {
    // define method signatures that describe the behaviors of the types that can implement this trait
    // the compiler will enforce that any type that has the Summary trait will have the method summarize defined with this signature exactly.
    fn summarize(&self) -> String;
}
#+END_SRC

** Implementing a Trait on a Type

   Now that we've defined the Summary trait, we can implement it on the types in our media aggregator.
   
#+name:
#+BEGIN_SRC rust
#![allow(unused)]
pub trait Summary {
    fn summarize(&self) -> String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}

fn main() {
    let example = NewsArticle {
        headline: "To the Internet!".to_string(),
        location: "The Internet".to_string(),
        author: "Everyone".to_string(),
        content: "yes".to_string(),
    };

    let example2 = Tweet {
        username: "blah".to_string(),
        content: "not much to say".to_string(),
        reply: true,
        retweet: true,
    };

    println!(
        "News Article:\t{}\nTweet:\t{}",
        example.summarize(),
        example2.summarize()
    );
}
#+END_SRC

Implementing a trait on a type is similar to implementing regular methods.
The difference is that after impl, we put the trait name that we want to implement, then use the for keyword, and then specify the name of the type we want to implement the trait for.

One restriction to note with trait implementations is that we can implement a trait on a type only if either the trait or the type is local to our crate.

** Default Implementations

   Sometimes it's useful to have default behavior for some or all of the methods in a trait instead of requiring implementations for all methods on every type.
   Then, as we implement the trait on a particular type, we can override each method's default behavior.

   We can specify a default string for the summarize method of the Summary trait instead of defining the method signature:

#+name:
#+BEGIN_SRC rust
pub trait Summary {
    fn summarize(&self) -> String {
	String::from("(Read more...)")
    }
}
#+END_SRC

To use a default implementation to summarize, we specify an empty impl block

#+name:
#+BEGIN_SRC rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}

impl Summary for NewsArticle {}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

fn main() {
    let article = NewsArticle {
        headline: "Penguins".to_string(),
        location: "Antarctica".to_string(),
        author: "GTP4".to_string(),
        content: "The Pittsburgh Penguins have somehow ended up in Antarctica".to_string(),
    };

    println!("News Article:\t{}", article.summarize());
}
#+END_SRC

Creating a default implementation for summarize doesn't allow us to change anything about the implementation of summary on another struct. The syntax for implementing a default implementation is the same as the syntax for implementing a trait method that doesn't have a default implementation.

Default implementations can call other methods in the same trait, even if those other methods don't have a default implementation. In this way, a trait can provude a lot of useful functionality and only require implementors to specify a small part of it.

#+name:
#+BEGIN_SRC rust
#![allow(unused)]

// we only need to define summarize_author when we implement the trait on a type
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}

fn main() {
    let tweet = Tweet {
        username: "horse_ebooks".to_string(),
        content: "Of course, as you probably know, people".to_string(),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
#+END_SRC

#+RESULTS: 
: 1 new tweet: (Read more from @horse_ebooks...)

Note that it isn't possible to call the default implementation from an overriding implementation of that same method.

** Traits as Parameters

